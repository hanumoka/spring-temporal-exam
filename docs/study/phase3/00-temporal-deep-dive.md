# Temporal 심층 학습 가이드

> **대상**: Temporal을 처음 접하는 개발자
> **목표**: 인프라부터 코드까지 완전한 이해
> **작성일**: 2026-02-07 (갱신)
> **참고**: [Temporal 공식 문서](https://docs.temporal.io/)
> **관련 문서**:
> - [05-temporal-faq.md](./05-temporal-faq.md) - 자주 묻는 질문
> - [06-temporal-activity-design-guide.md](./06-temporal-activity-design-guide.md) - Activity 설계 가이드 (멱등성, 동시성, Saga 격리)

---

## 목차

1. [Temporal이란 무엇인가?](#1-temporal이란-무엇인가)
2. [왜 Temporal이 필요한가?](#2-왜-temporal이-필요한가)
3. [핵심 개념 5가지](#3-핵심-개념-5가지)
4. [Durable Execution 완전 이해](#4-durable-execution-완전-이해)
5. [Event History와 Replay](#5-event-history와-replay)
6. [결정적 코드 규칙](#6-결정적-코드-규칙)
7. [Signal, Query, Update](#7-signal-query-update)
8. [Saga 패턴과 보상 트랜잭션](#8-saga-패턴과-보상-트랜잭션)
9. [재시도 정책과 타임아웃](#9-재시도-정책과-타임아웃)
10. [Spring Boot 통합](#10-spring-boot-통합)
11. [실전 예제: 주문 처리 Workflow](#11-실전-예제-주문-처리-workflow)

---

## 1. Temporal이란 무엇인가?

### 1.1 한 줄 정의

> **Temporal**은 **"절대 실패하지 않는 코드"**를 작성할 수 있게 해주는 플랫폼입니다.

공식적으로 Temporal은 **Durable Execution(내구성 있는 실행)** 플랫폼이라고 합니다.

### 1.2 가장 쉬운 비유

**일반 코드 vs Temporal 코드**

```
┌─────────────────────────────────────────────────────────────────────────────┐
│                          일반 코드의 문제                                    │
├─────────────────────────────────────────────────────────────────────────────┤
│                                                                              │
│   당신이 요리를 하고 있다고 상상해보세요:                                     │
│                                                                              │
│   1. 양파를 썬다 ✅                                                         │
│   2. 고기를 굽는다 ✅                                                        │
│   3. 소스를 만든다... 💥 (정전!)                                            │
│                                                                              │
│   정전이 복구되면?                                                           │
│   → 처음부터 다시 시작해야 함                                                │
│   → 이미 썬 양파는 어디 있는지 모름                                          │
│   → 고기가 다 탔는지도 모름                                                  │
│                                                                              │
└─────────────────────────────────────────────────────────────────────────────┘

┌─────────────────────────────────────────────────────────────────────────────┐
│                          Temporal 코드의 장점                                │
├─────────────────────────────────────────────────────────────────────────────┤
│                                                                              │
│   Temporal과 함께라면:                                                       │
│                                                                              │
│   1. 양파를 썬다 ✅ (기록됨)                                                 │
│   2. 고기를 굽는다 ✅ (기록됨)                                               │
│   3. 소스를 만든다... 💥 (정전!)                                            │
│                                                                              │
│   정전이 복구되면?                                                           │
│   → "아, 양파 썰기랑 고기 굽기는 끝났네"                                     │
│   → 3번 소스 만들기부터 이어서 진행!                                         │
│                                                                              │
│   이것이 바로 "Durable Execution"입니다.                                    │
│                                                                              │
└─────────────────────────────────────────────────────────────────────────────┘
```

### 1.3 Temporal의 3가지 핵심 가치

| 가치 | 설명 | 예시 |
|------|------|------|
| **Durability (내구성)** | 서버가 죽어도 상태가 보존됨 | 결제 중 서버 재시작 → 이어서 진행 |
| **Reliability (신뢰성)** | 실패하면 자동으로 재시도 | 네트워크 오류 → 자동 재시도 |
| **Visibility (가시성)** | 모든 실행 상태를 UI에서 확인 | "지금 주문이 어디까지 진행됐지?" |

### 1.4 Temporal의 역사

```
2016년: Uber에서 Cadence 프로젝트 시작
        └── 대규모 분산 시스템 오케스트레이션 필요

2019년: Cadence 핵심 개발자들이 Temporal Technologies 설립
        └── 오픈소스 + 상업적 지원

2020년: Temporal 1.0 출시

2024년: Spring Boot Starter 공식 GA
        └── Temporal Java SDK 1.20+ 부터 지원

현재: Temporal Spring Boot Starter 1.26.0
      └── 이 프로젝트에서 사용 중인 버전
      └── gradle/libs.versions.toml 참조
```

---

## 2. 왜 Temporal이 필요한가?

### 2.1 분산 시스템의 현실

이론적으로 마이크로서비스는 이렇게 동작해야 합니다:

```
클라이언트 → 주문서비스 → 재고서비스 → 결제서비스 → 완료!
              ✅           ✅           ✅
```

하지만 현실은 이렇습니다:

```
┌─────────────────────────────────────────────────────────────────────────────┐
│                        분산 시스템에서 일어나는 일들                          │
├─────────────────────────────────────────────────────────────────────────────┤
│                                                                              │
│  [상황 1] 네트워크 일시 장애                                                 │
│  클라이언트 → 주문서비스 ──X── 재고서비스                                    │
│                           ↑                                                 │
│                       네트워크 끊김                                          │
│                                                                              │
│  [상황 2] 서비스 다운                                                        │
│  클라이언트 → 주문서비스 → 재고서비스 ──X── 결제서비스                       │
│                                        ↑                                    │
│                                    서버 다운                                 │
│                                                                              │
│  [상황 3] 타임아웃                                                           │
│  클라이언트 → 주문서비스 → 재고서비스 → 결제서비스                           │
│                                              ↓                              │
│                                          응답 지연 (30초)                    │
│                                              ↓                              │
│                                          타임아웃!                           │
│                                                                              │
│  [상황 4] 중간에 서버 재시작                                                 │
│  주문 생성 ✅ → 재고 예약 ✅ → 결제 처리 중... 💥 (서버 재시작)              │
│                                                                              │
│  질문: 결제가 됐나요, 안 됐나요?                                             │
│                                                                              │
└─────────────────────────────────────────────────────────────────────────────┘
```

### 2.2 직접 해결하려면 얼마나 복잡한가?

**Phase 2-A에서 우리가 구현한 것들:**

| 문제 | 우리의 해결책 | 코드량 | 복잡도 |
|------|-------------|--------|--------|
| 중복 처리 | 멱등성 (IdempotencyService) | ~200줄 | 높음 |
| 일시적 실패 | Resilience4j Retry | ~100줄 | 중간 |
| 연쇄 장애 | Resilience4j CircuitBreaker | ~50줄 | 중간 |
| 동시성 제어 | RLock + Semantic Lock | ~300줄 | 매우 높음 |
| 보상 트랜잭션 | OrderSagaOrchestrator | 167줄 | 높음 |
| **합계** | | **~800줄+** | |

### 2.3 Temporal이 해결하는 것 vs 해결하지 않는 것

> **중요**: Temporal은 **만능이 아닙니다!** 정확히 어떤 문제를 해결하고, 어떤 문제는 여전히 직접 처리해야 하는지 구분해야 합니다.

```
┌─────────────────────────────────────────────────────────────────────────────┐
│              Temporal이 해결하는 것 vs 해결하지 않는 것                       │
├─────────────────────────────────────────────────────────────────────────────┤
│                                                                              │
│  ✅ Temporal이 해결하는 것 (오케스트레이션 레벨)                             │
│  ═════════════════════════════════════════════                               │
│                                                                              │
│  • 일시적 실패 + 재시도                                                      │
│    → RetryOptions로 선언적 설정                                              │
│    → Resilience4j Retry 불필요 (~100줄 삭제)                                │
│                                                                              │
│  • 보상 트랜잭션 (Saga)                                                      │
│    → Saga.addCompensation()으로 간단하게                                    │
│    → OrderSagaOrchestrator 불필요 (~167줄 삭제)                             │
│                                                                              │
│  • 상태 저장 + 크래시 복구                                                   │
│    → Event History로 자동 관리                                              │
│    → 상태 관리 코드 불필요                                                   │
│                                                                              │
│  • 가시성 (모니터링)                                                         │
│    → Temporal UI에서 실시간 확인                                             │
│                                                                              │
├─────────────────────────────────────────────────────────────────────────────┤
│                                                                              │
│  ❌ Temporal이 해결하지 않는 것 (비즈니스 로직 레벨)                          │
│  ═══════════════════════════════════════════════════                         │
│                                                                              │
│  • 멱등성 (Idempotency) - 여전히 필요!                                       │
│    → Activity 재시도 시 이중 처리 방지                                       │
│    → IdempotencyService 여전히 필요 (~200줄 유지)                           │
│                                                                              │
│  • 동시성 제어 (분산 락) - 여전히 필요!                                       │
│    → 동일 리소스에 대한 동시 접근 제어                                       │
│    → RLock + Semantic Lock 여전히 필요 (~300줄 유지)                        │
│                                                                              │
│  • 서킷 브레이커 - 상황에 따라 필요                                          │
│    → 외부 서비스 완전 장애 시 무한 재시도 방지                               │
│    → Activity 내부에서 선택적 사용                                           │
│                                                                              │
└─────────────────────────────────────────────────────────────────────────────┘
```

### 2.4 왜 멱등성은 Temporal이 해결 못 하는가?

```
┌─────────────────────────────────────────────────────────────────────────────┐
│                      멱등성이 여전히 필요한 이유                              │
├─────────────────────────────────────────────────────────────────────────────┤
│                                                                              │
│  [시나리오] 결제 Activity 실행 중 문제 발생                                  │
│                                                                              │
│  ┌──────────────────────────────────────────────────────────────────────┐   │
│  │                                                                       │   │
│  │  Worker                           결제 API                            │   │
│  │    │                                 │                                │   │
│  │    │ ── 결제 요청 (100,000원) ────▶ │                                │   │
│  │    │                                 │                                │   │
│  │    │                                 │ (결제 성공! 카드 100,000원 차감)│   │
│  │    │                                 │                                │   │
│  │    │ ◀── 응답 반환 중... ─────────── │                                │   │
│  │    │         │                       │                                │   │
│  │    │         💥 네트워크 끊김!       │                                │   │
│  │    │                                 │                                │   │
│  │    │                                                                  │   │
│  │    │ [Temporal의 판단]                                                │   │
│  │    │ "응답을 못 받았으니 Activity 실패로 간주"                         │   │
│  │    │ "재시도하자!"                                                    │   │
│  │    │                                 │                                │   │
│  │    │ ── 결제 요청 (100,000원) ────▶ │  ← 다시 호출!                   │   │
│  │    │                                 │                                │   │
│  │    │                                 │ (결제 성공! 카드 100,000원 차감)│   │
│  │    │                                 │                                │   │
│  │  결과: 200,000원 이중 결제! ❌                                         │   │
│  │                                                                       │   │
│  └──────────────────────────────────────────────────────────────────────┘   │
│                                                                              │
│  [해결책] Activity 내부에서 멱등성 보장                                      │
│                                                                              │
│  @Override                                                                   │
│  public String processPayment(String orderId, String idempotencyKey) {      │
│      // 이미 처리된 결제인지 확인                                            │
│      PaymentRecord existing = paymentRepository.findByKey(idempotencyKey);  │
│      if (existing != null) {                                                │
│          return existing.getPaymentId();  // 기존 결과 반환                  │
│      }                                                                       │
│                                                                              │
│      // 최초 요청만 실제 처리                                                │
│      String paymentId = paymentClient.charge(orderId);                      │
│      paymentRepository.save(new PaymentRecord(idempotencyKey, paymentId));  │
│      return paymentId;                                                       │
│  }                                                                           │
│                                                                              │
│  핵심: Temporal은 "Activity를 다시 호출할 뿐", 이중 처리 방지는 개발자 책임!  │
│                                                                              │
└─────────────────────────────────────────────────────────────────────────────┘
```

### 2.5 왜 동시성 제어는 Temporal이 해결 못 하는가?

```
┌─────────────────────────────────────────────────────────────────────────────┐
│                     동시성 제어가 여전히 필요한 이유                          │
├─────────────────────────────────────────────────────────────────────────────┤
│                                                                              │
│  [시나리오] 같은 상품에 동시 주문                                            │
│                                                                              │
│  재고: 상품A = 1개                                                           │
│                                                                              │
│  ┌────────────────────────────────────────────────────────────────────┐     │
│  │                                                                     │     │
│  │  Workflow 1 (주문 1)              Workflow 2 (주문 2)               │     │
│  │       │                                │                            │     │
│  │       │  시간 ───────────────────────────────────────────────▶      │     │
│  │       │                                │                            │     │
│  │       ├── 재고 확인 ──────────┐        │                            │     │
│  │       │   "재고 1개 있음" ◀───┘        │                            │     │
│  │       │                                ├── 재고 확인 ──────────┐    │     │
│  │       │                                │   "재고 1개 있음" ◀───┘    │     │
│  │       │                                │                            │     │
│  │       ├── 재고 예약 ──────────────────▶ DB: 재고 = 0              │     │
│  │       │   "예약 성공!"                 │                            │     │
│  │       │                                ├── 재고 예약 ───────────▶   │     │
│  │       │                                │   "재고 부족 에러!" ❌     │     │
│  │       │                                │                            │     │
│  │  결과: Workflow 2는 고객에게 "주문 실패" 응답 (재고 있다고 했는데!)  │     │
│  │        더 심각한 경우: Race Condition으로 재고가 -1이 될 수도!       │     │
│  │                                                                     │     │
│  └────────────────────────────────────────────────────────────────────┘     │
│                                                                              │
│  왜 Temporal이 해결 못 하는가?                                               │
│  ─────────────────────────────                                               │
│  • 각 Workflow는 완전히 독립적으로 실행됨                                    │
│  • Temporal은 "Workflow 간 조율"을 하지 않음                                 │
│  • 공유 리소스(재고)에 대한 동시 접근은 비즈니스 로직 영역                    │
│                                                                              │
│  [해결책] Activity 내부에서 분산 락 사용                                     │
│                                                                              │
│  @Override                                                                   │
│  public void reserveStock(String productId, int quantity) {                 │
│      RLock lock = redisson.getLock("stock:" + productId);                   │
│      try {                                                                   │
│          if (lock.tryLock(5, 30, TimeUnit.SECONDS)) {                       │
│              int stock = inventoryRepository.getStock(productId);           │
│              if (stock < quantity) {                                        │
│                  throw new InsufficientStockException();                    │
│              }                                                               │
│              inventoryRepository.decreaseStock(productId, quantity);        │
│          } else {                                                           │
│              throw new LockAcquisitionException("재고 락 획득 실패");        │
│          }                                                                   │
│      } finally {                                                             │
│          if (lock.isHeldByCurrentThread()) {                                │
│              lock.unlock();                                                  │
│          }                                                                   │
│      }                                                                       │
│  }                                                                           │
│                                                                              │
└─────────────────────────────────────────────────────────────────────────────┘
```

### 2.6 분산 트랜잭션 관점에서의 Temporal

```
┌─────────────────────────────────────────────────────────────────────────────┐
│                   분산 트랜잭션: 2PC vs Saga vs Temporal                      │
├─────────────────────────────────────────────────────────────────────────────┤
│                                                                              │
│  [방식 1] 2PC (Two-Phase Commit) - 강한 일관성                               │
│  ═══════════════════════════════════════════                                 │
│                                                                              │
│    Coordinator                                                               │
│        │                                                                     │
│        ├── Prepare ──▶ DB1 (주문)   "준비됐어?"                              │
│        ├── Prepare ──▶ DB2 (재고)   "준비됐어?"                              │
│        ├── Prepare ──▶ DB3 (결제)   "준비됐어?"                              │
│        │                                                                     │
│        │   모두 "YES" 응답 시:                                               │
│        │                                                                     │
│        ├── Commit ───▶ DB1          "커밋해!"                                │
│        ├── Commit ───▶ DB2          "커밋해!"                                │
│        └── Commit ───▶ DB3          "커밋해!"                                │
│                                                                              │
│    문제점:                                                                   │
│    • 모든 서비스가 락을 잡고 대기 → 성능 저하                                │
│    • Coordinator가 죽으면? → 전체 블로킹                                     │
│    • MSA 환경에서 구현 매우 어려움                                           │
│                                                                              │
├─────────────────────────────────────────────────────────────────────────────┤
│                                                                              │
│  [방식 2] Saga 패턴 - 최종 일관성 (Eventual Consistency)                     │
│  ═══════════════════════════════════════════════════════                     │
│                                                                              │
│    T1: 주문 생성 ──▶ C1: 주문 취소                                          │
│          │                  ▲                                                │
│          ▼                  │                                                │
│    T2: 재고 예약 ──▶ C2: 재고 해제                                          │
│          │                  ▲                                                │
│          ▼                  │                                                │
│    T3: 결제 처리 ─❌─▶ 실패 시 C2 → C1 순서로 보상                          │
│                                                                              │
│    특징:                                                                     │
│    • 각 단계는 즉시 커밋 (락 없음)                                           │
│    • 실패 시 보상 트랜잭션으로 롤백                                          │
│    • 중간 상태가 일시적으로 노출됨 (Dirty Read 가능)                         │
│                                                                              │
├─────────────────────────────────────────────────────────────────────────────┤
│                                                                              │
│  [방식 3] Temporal = Saga 패턴의 완벽한 구현체                               │
│  ═══════════════════════════════════════════════                             │
│                                                                              │
│    Temporal이 제공하는 것:                                                   │
│    ✅ Saga 실행 순서 보장                                                    │
│    ✅ 실패 시 보상 자동 실행                                                 │
│    ✅ 보상 실패 시 재시도                                                    │
│    ✅ 전체 상태 기록 (Event History)                                         │
│    ✅ 크래시 복구                                                            │
│                                                                              │
│    Temporal이 제공하지 않는 것:                                              │
│    ❌ ACID 트랜잭션 (Atomicity)                                              │
│    ❌ 강한 일관성 (2PC처럼)                                                  │
│    ❌ Isolation (중간 상태 노출 방지)                                        │
│                                                                              │
│    결론:                                                                     │
│    Temporal은 "Saga 패턴을 쉽게 구현"해주는 도구이지,                        │
│    "분산 트랜잭션의 ACID를 보장"해주는 도구가 아닙니다.                       │
│                                                                              │
└─────────────────────────────────────────────────────────────────────────────┘
```

### 2.7 EDA(Event-Driven Architecture) 관점에서의 Temporal

```
┌─────────────────────────────────────────────────────────────────────────────┐
│               EDA vs Temporal: 상호 보완적 관계                               │
├─────────────────────────────────────────────────────────────────────────────┤
│                                                                              │
│  [EDA - Choreography 방식]                                                   │
│  ═══════════════════════════                                                 │
│                                                                              │
│    주문서비스 ──OrderCreated──▶ Kafka ──▶ 재고서비스                        │
│                                    │                                         │
│                                    └──▶ 결제서비스                          │
│                                    │                                         │
│                                    └──▶ 알림서비스                          │
│                                                                              │
│    장점:                                                                     │
│    • 느슨한 결합 (서비스 간 직접 호출 없음)                                   │
│    • 높은 확장성 (새 구독자 쉽게 추가)                                        │
│    • 비동기 처리                                                             │
│                                                                              │
│    단점:                                                                     │
│    • 전체 흐름 파악 어려움 (이벤트 추적 필요)                                 │
│    • 실패 시 보상 복잡 (누가 어디까지 처리했는지?)                            │
│    • 순서 보장 어려움                                                         │
│    • 디버깅 지옥                                                             │
│                                                                              │
├─────────────────────────────────────────────────────────────────────────────┤
│                                                                              │
│  [Temporal - Orchestration 방식]                                             │
│  ═════════════════════════════════                                           │
│                                                                              │
│         ┌─────────────────┐                                                  │
│         │   Orchestrator  │  ← Temporal Workflow                             │
│         │   (중앙 지휘자) │                                                  │
│         └───────┬─────────┘                                                  │
│                 │                                                            │
│         ┌───────┼───────┬───────────┐                                        │
│         ▼       ▼       ▼           ▼                                        │
│      주문    재고     결제        알림                                        │
│                                                                              │
│    장점:                                                                     │
│    • 전체 흐름이 코드로 명확히 보임                                          │
│    • 실패 시 보상이 간단 (Saga)                                              │
│    • 상태 추적 쉬움 (Temporal UI)                                            │
│    • 디버깅 쉬움                                                             │
│                                                                              │
│    단점:                                                                     │
│    • 오케스트레이터가 병목이 될 수 있음                                       │
│    • 서비스 간 결합도 증가                                                   │
│                                                                              │
├─────────────────────────────────────────────────────────────────────────────┤
│                                                                              │
│  [Best Practice: 함께 사용하기]                                              │
│  ══════════════════════════════                                              │
│                                                                              │
│    핵심 비즈니스 흐름 = Temporal (Orchestration)                             │
│    ───────────────────────────────────────────────                           │
│    • 주문 → 재고 → 결제 → 배송 (순서와 보상이 중요)                          │
│    • 상태 추적과 복구가 필요한 흐름                                          │
│                                                                              │
│    부가 기능/알림 = EDA (Choreography)                                        │
│    ────────────────────────────────────                                      │
│    • 주문 완료 이벤트 → 마케팅, 분석, 알림 서비스                            │
│    • 순서나 보상이 중요하지 않은 흐름                                        │
│    • 다대다 이벤트 전파                                                      │
│                                                                              │
│    ┌───────────────────────────────────────────────────────────────────┐    │
│    │                                                                    │    │
│    │  Temporal Workflow                                                 │    │
│    │  ┌──────────────────────────────────────────────────────────────┐ │    │
│    │  │ 1. 주문 생성                                                  │ │    │
│    │  │ 2. 재고 예약                                                  │ │    │
│    │  │ 3. 결제 처리                                                  │ │    │
│    │  │ 4. 배송 시작                                                  │ │    │
│    │  │ 5. 이벤트 발행 ◀── Activity로 Kafka에 이벤트 발행             │ │    │
│    │  └──────────────────────────────────────────────────────────────┘ │    │
│    │                    │                                               │    │
│    │                    │ OrderCompletedEvent                           │    │
│    │                    ▼                                               │    │
│    │  ┌───────────────────────────────────────────────────────────────┐│    │
│    │  │                     Kafka                                      ││    │
│    │  └───────────┬────────────────┬────────────────┬─────────────────┘│    │
│    │              │                │                │                   │    │
│    │              ▼                ▼                ▼                   │    │
│    │         알림서비스        분석서비스       마케팅서비스             │    │
│    │                                                                    │    │
│    └───────────────────────────────────────────────────────────────────┘    │
│                                                                              │
└─────────────────────────────────────────────────────────────────────────────┘
```

### 2.8 통신 방식 선택: REST vs EDA + Temporal

> **중요**: EDA를 사용한다고 해서 Choreography가 필수는 아닙니다.
> EDA(통신 방식)와 Choreography/Orchestration(조정 패턴)은 **독립적인 개념**입니다.

```
┌─────────────────────────────────────────────────────────────────────────────┐
│                    개념 분리: 통신 방식 vs 조정 패턴                          │
├─────────────────────────────────────────────────────────────────────────────┤
│                                                                              │
│  EDA (Event-Driven Architecture) = "통신 방식" (HOW to communicate)         │
│  Choreography / Orchestration = "조정 패턴" (WHO controls the flow)         │
│                                                                              │
│  ┌───────────────────┬───────────────────┬───────────────────────────┐     │
│  │                   │   Choreography    │     Orchestration         │     │
│  ├───────────────────┼───────────────────┼───────────────────────────┤     │
│  │  EDA (이벤트)     │   ✅ 가능         │     ✅ 가능               │     │
│  │  REST (동기)      │   ✅ 가능         │     ✅ 가능               │     │
│  └───────────────────┴───────────────────┴───────────────────────────┘     │
│                                                                              │
│  ★ 4가지 조합이 모두 가능! EDA + Orchestration도 일반적인 패턴              │
│                                                                              │
└─────────────────────────────────────────────────────────────────────────────┘
```

#### REST + Temporal Orchestration (현재 예제)

```
┌─────────────────────────────────────────────────────────────────────────────┐
│                                                                              │
│  Temporal Workflow                                                          │
│       │                                                                     │
│       ├── Activity ─── REST ───▶ 주문 서비스                                │
│       ├── Activity ─── REST ───▶ 재고 서비스                                │
│       ├── Activity ─── REST ───▶ 결제 서비스                                │
│       └── Activity ─── REST ───▶ 알림 서비스                                │
│                                                                              │
│  특징: 동기 통신 (요청-응답), 간단하고 직관적                                │
│                                                                              │
└─────────────────────────────────────────────────────────────────────────────┘
```

#### EDA + Temporal Orchestration (대안 패턴)

```
┌─────────────────────────────────────────────────────────────────────────────┐
│                                                                              │
│  Temporal Workflow                                                          │
│       │                                                                     │
│       ├── Activity ─── Kafka ───▶ ReserveStockCommand                      │
│       │                                   │                                 │
│       │       ◀─── Kafka ─── StockReservedEvent (Signal 또는 Polling)      │
│       │                                                                     │
│       ├── Activity ─── Kafka ───▶ ProcessPaymentCommand                    │
│       │                                   │                                 │
│       │       ◀─── Kafka ─── PaymentCompletedEvent                         │
│       │                                                                     │
│       └── ...                                                               │
│                                                                              │
│  특징: 비동기 통신 (이벤트 기반), 느슨한 결합                                │
│                                                                              │
└─────────────────────────────────────────────────────────────────────────────┘
```

#### 두 패턴 비교

```
┌─────────────────────────────────────────────────────────────────────────────┐
│              REST + Temporal vs EDA + Temporal 장단점 비교                   │
├─────────────────────────────────────────────────────────────────────────────┤
│                                                                              │
│  ┌─────────────────────────────────────────────────────────────────────┐   │
│  │  REST + Temporal Orchestration                                       │   │
│  ├─────────────────────────────────────────────────────────────────────┤   │
│  │                                                                      │   │
│  │  장점:                                                               │   │
│  │  ✅ 구현이 단순하고 직관적                                           │   │
│  │  ✅ 디버깅 용이 (요청-응답 추적 쉬움)                                │   │
│  │  ✅ 즉각적인 응답 확인 가능                                          │   │
│  │  ✅ 추가 인프라 불필요 (Kafka 등)                                    │   │
│  │  ✅ 학습 곡선 낮음                                                   │   │
│  │                                                                      │   │
│  │  단점:                                                               │   │
│  │  ❌ 서비스 간 직접 의존 (결합도 높음)                                │   │
│  │  ❌ 서비스 URL/엔드포인트 변경 시 영향                               │   │
│  │  ❌ 서비스 다운 시 즉시 실패 (Temporal이 재시도하지만)               │   │
│  │  ❌ 이벤트 로그/감사 추적 별도 구현 필요                             │   │
│  │                                                                      │   │
│  │  적합한 경우:                                                        │   │
│  │  • 신규 프로젝트, 처음부터 설계                                      │   │
│  │  • 서비스 수가 적고 관리 가능한 규모                                 │   │
│  │  • 빠른 개발이 중요한 경우                                           │   │
│  │  • 동기 응답이 필요한 경우                                           │   │
│  │                                                                      │   │
│  └─────────────────────────────────────────────────────────────────────┘   │
│                                                                              │
│  ┌─────────────────────────────────────────────────────────────────────┐   │
│  │  EDA + Temporal Orchestration                                        │   │
│  ├─────────────────────────────────────────────────────────────────────┤   │
│  │                                                                      │   │
│  │  장점:                                                               │   │
│  │  ✅ 서비스 간 느슨한 결합 (서비스가 서로 모름)                       │   │
│  │  ✅ 기존 EDA 인프라 활용 가능                                        │   │
│  │  ✅ 이벤트 로그 자동 보존 (Kafka 로그)                               │   │
│  │  ✅ 여러 Consumer가 같은 이벤트 구독 가능                            │   │
│  │  ✅ 레거시 시스템 통합 용이 (이벤트로만 통신)                        │   │
│  │  ✅ 서비스 일시 다운 시 메시지 버퍼링                                │   │
│  │                                                                      │   │
│  │  단점:                                                               │   │
│  │  ❌ 구현 복잡도 증가 (Command/Reply 패턴)                            │   │
│  │  ❌ 추가 인프라 필요 (Kafka, RabbitMQ 등)                            │   │
│  │  ❌ 디버깅 복잡 (이벤트 흐름 추적 필요)                              │   │
│  │  ❌ 응답 대기 로직 필요 (Signal, Polling)                            │   │
│  │  ❌ 메시지 순서, 중복 처리 고려 필요                                 │   │
│  │                                                                      │   │
│  │  적합한 경우:                                                        │   │
│  │  • 기존 Kafka/RabbitMQ 인프라가 있는 경우                            │   │
│  │  • 대규모 MSA (수십~수백 개 서비스)                                  │   │
│  │  • 이벤트 기록/감사가 필수인 경우                                    │   │
│  │  • 레거시 시스템 통합 필요                                           │   │
│  │  • 느슨한 결합이 중요한 경우                                         │   │
│  │                                                                      │   │
│  └─────────────────────────────────────────────────────────────────────┘   │
│                                                                              │
└─────────────────────────────────────────────────────────────────────────────┘
```

#### EDA + Temporal 구현 예시

```java
// 방법 1: Activity에서 이벤트 발행 + Signal로 결과 수신
@WorkflowInterface
public interface OrderWorkflow {
    @WorkflowMethod
    OrderResult processOrder(OrderRequest request);

    @SignalMethod
    void onStockReserved(StockReservedEvent event);

    @SignalMethod
    void onPaymentCompleted(PaymentCompletedEvent event);
}

public class OrderWorkflowImpl implements OrderWorkflow {
    private StockReservedEvent stockResult;
    private PaymentCompletedEvent paymentResult;

    @Override
    public OrderResult processOrder(OrderRequest request) {
        // 1. 명령 이벤트 발행
        String correlationId = activities.publishReserveStockCommand(
            request.productId(), request.quantity());

        // 2. Signal로 결과 대기
        Workflow.await(() -> stockResult != null);

        if (!stockResult.isSuccess()) {
            return OrderResult.failure("재고 예약 실패");
        }

        // 3. 결제 명령 발행
        activities.publishPaymentCommand(request.orderId(), request.amount());

        // 4. 결제 결과 대기
        Workflow.await(() -> paymentResult != null);

        return OrderResult.success(request.orderId());
    }

    @Override
    public void onStockReserved(StockReservedEvent event) {
        this.stockResult = event;
    }

    @Override
    public void onPaymentCompleted(PaymentCompletedEvent event) {
        this.paymentResult = event;
    }
}
```

#### 하이브리드 패턴 (권장)

```
┌─────────────────────────────────────────────────────────────────────────────┐
│                    실전 권장: 하이브리드 패턴                                │
├─────────────────────────────────────────────────────────────────────────────┤
│                                                                              │
│  핵심 비즈니스 흐름 = REST + Temporal (직접 제어, 명확한 흐름)               │
│  부가 기능/알림 = EDA (느슨한 결합, 확장 용이)                               │
│                                                                              │
│  ┌───────────────────────────────────────────────────────────────────────┐  │
│  │                                                                        │  │
│  │  Temporal Workflow                                                     │  │
│  │       │                                                                │  │
│  │       ├── Activity (REST) → 주문 서비스      ◀── 핵심 흐름            │  │
│  │       ├── Activity (REST) → 재고 서비스      ◀── (순서, 보상 중요)    │  │
│  │       ├── Activity (REST) → 결제 서비스                                │  │
│  │       │                                                                │  │
│  │       └── Activity (Kafka) → OrderCompletedEvent 발행                 │  │
│  │                                    │                                   │  │
│  │                    ┌───────────────┼───────────────┐                   │  │
│  │                    ▼               ▼               ▼                   │  │
│  │               알림서비스       분석서비스       마케팅서비스            │  │
│  │               (Choreography - 순서/보상 중요하지 않음)                 │  │
│  │                                                                        │  │
│  └───────────────────────────────────────────────────────────────────────┘  │
│                                                                              │
│  장점:                                                                      │
│  • 핵심 흐름은 명확하고 디버깅 쉬움                                         │
│  • 부가 기능은 느슨하게 결합되어 확장 용이                                  │
│  • 각 영역에 적합한 패턴 선택                                               │
│                                                                              │
└─────────────────────────────────────────────────────────────────────────────┘
```

#### 실제 사용 사례

| 회사/프로젝트 | 패턴 | 설명 |
|--------------|------|------|
| **Uber** | EDA + Temporal | Cadence(Temporal 전신)로 Kafka 이벤트 오케스트레이션 |
| **Netflix** | EDA + Conductor | Kafka + 자체 오케스트레이션 엔진 |
| **Doordash** | EDA + Temporal | 주문 처리에 Kafka + Temporal 조합 |
| **Stripe** | REST + Temporal | 결제 흐름에 REST 기반 Temporal |

#### 패턴 선택 의사결정

```
┌─────────────────────────────────────────────────────────────────────────────┐
│                         패턴 선택 체크리스트                                 │
├─────────────────────────────────────────────────────────────────────────────┤
│                                                                              │
│  Q1: 기존에 Kafka/RabbitMQ 인프라가 있는가?                                 │
│      ├─ YES → EDA + Temporal 고려                                           │
│      └─ NO  → REST + Temporal (더 단순)                                     │
│                                                                              │
│  Q2: 서비스 수가 많은가? (10개 이상)                                        │
│      ├─ YES → EDA + Temporal (느슨한 결합 중요)                             │
│      └─ NO  → REST + Temporal (관리 가능)                                   │
│                                                                              │
│  Q3: 이벤트 로그/감사가 필수인가?                                           │
│      ├─ YES → EDA + Temporal (Kafka 로그 활용)                              │
│      └─ NO  → 둘 다 가능                                                    │
│                                                                              │
│  Q4: 레거시 시스템과 통합해야 하는가?                                       │
│      ├─ YES → EDA + Temporal (이벤트 기반 통합)                             │
│      └─ NO  → REST + Temporal                                               │
│                                                                              │
│  Q5: 빠른 개발이 우선인가?                                                  │
│      ├─ YES → REST + Temporal (단순함)                                      │
│      └─ NO  → 요구사항에 맞게 선택                                          │
│                                                                              │
│  ★ 확실하지 않다면: REST + Temporal로 시작, 필요 시 EDA로 전환              │
│     (Activity 내부만 변경하면 됨, Workflow는 그대로)                         │
│                                                                              │
└─────────────────────────────────────────────────────────────────────────────┘
```

### 2.9 코드량 변화 정리 (정확한 비교)

```
┌─────────────────────────────────────────────────────────────────────────────┐
│                    Phase 2-A → Temporal 도입 후 변화                          │
├─────────────────────────────────────────────────────────────────────────────┤
│                                                                              │
│  문제              │ Phase 2-A    │ Temporal 후    │ 변화                    │
│  ─────────────────┼──────────────┼────────────────┼────────────────────────│
│  재시도 로직       │ ~100줄       │ ~5줄 (설정만)  │ ✅ 95% 삭제            │
│  서킷브레이커      │ ~50줄        │ 0~50줄         │ ⚠️ 상황에 따라 유지    │
│  보상 트랜잭션     │ ~167줄       │ ~20줄          │ ✅ 88% 삭제            │
│  상태 관리         │ ~100줄       │ 0줄 (자동)     │ ✅ 100% 삭제           │
│  멱등성           │ ~200줄       │ ~200줄         │ ❌ 그대로 유지          │
│  동시성 제어       │ ~300줄       │ ~300줄         │ ❌ 그대로 유지          │
│  ─────────────────┼──────────────┼────────────────┼────────────────────────│
│  합계             │ ~917줄       │ ~575줄         │ 약 37% 감소            │
│                                                                              │
│  ★ 추가로 얻는 것 (코드 0줄로):                                             │
│    • 상태 자동 저장/복구 (크래시 후 이어서 실행)                             │
│    • 실행 이력 자동 기록 (Event History)                                     │
│    • 실시간 모니터링 (Temporal UI)                                           │
│    • 장시간 실행 지원 (며칠, 몇 달도 가능)                                   │
│                                                                              │
│  ★ 핵심 결론:                                                               │
│    Temporal은 "오케스트레이션 복잡도"를 크게 줄여주지만,                     │
│    "비즈니스 로직 복잡도"(멱등성, 동시성)는 여전히 개발자의 책임입니다.       │
│                                                                              │
└─────────────────────────────────────────────────────────────────────────────┘
```

**Temporal 코드 예시 (한계점 포함):**

```java
// Temporal Workflow - 보상 트랜잭션은 간단해짐
public OrderResult processOrder(OrderRequest request) {
    Saga saga = new Saga(new Saga.Options.Builder().build());

    try {
        // ✅ 재시도는 Temporal이 자동 처리
        // ✅ 크래시 복구는 Temporal이 자동 처리
        // ✅ 보상은 saga.compensate()로 간단히

        // Step 1: 주문 생성
        Long orderId = activities.createOrder(request);
        saga.addCompensation(() -> activities.cancelOrder(orderId));

        // Step 2: 재고 "예약" (Semantic Lock)
        // ❌ 하지만 Activity 내부에서는 여전히...
        //    - 멱등성 보장 필요 (IdempotencyKey)
        //    - 동시성 제어 필요 (분산 락)
        String reservationId = activities.reserveStock(request.productId(), request.quantity());
        saga.addCompensation(() -> activities.cancelReservation(reservationId));

        // Step 3: 결제 처리
        String paymentId = activities.processPayment(orderId, request.amount());
        saga.addCompensation(() -> activities.refundPayment(paymentId));

        // Step 4: 확정 (예약 → 실제 차감, 주문 상태 변경)
        // ★ 모든 단계 성공 후 확정해야 Semantic Lock이 해제됨
        activities.confirmReservation(reservationId);
        activities.confirmOrder(orderId);

        return OrderResult.success(orderId);

    } catch (ActivityFailure e) {
        saga.compensate();  // 자동으로 역순 실행!
        return OrderResult.failure(e.getMessage());
    }
}
```

> **중요**: `confirmReservation`과 `confirmOrder`는 보상 등록 없이 마지막에 호출합니다.
> 이 단계에서 실패하면 Temporal이 재시도하고, 그래도 실패하면 수동 개입이 필요합니다.
> (이미 결제까지 완료된 상태이므로 단순 보상으로 처리할 수 없음)

### 2.10 Temporal vs 다른 솔루션

| 솔루션 | 특징 | 적합한 사용처 |
|--------|------|--------------|
| **Temporal** | 코드 중심, 범용 | 마이크로서비스 오케스트레이션 |
| Apache Airflow | DAG 기반, Python | 데이터 파이프라인, ETL |
| AWS Step Functions | JSON 기반, AWS 종속 | AWS 네이티브 서비스 |
| Camunda | BPMN 기반, 비개발자 친화적 | 비즈니스 프로세스 관리 |

**Temporal의 차별점:**
- **코드가 곧 워크플로우**: JSON/YAML/GUI 대신 일반 Java 코드
- **클라우드 중립**: AWS, GCP, Azure, 온프레미스 모두 가능
- **언어 다양성**: Java, Go, TypeScript, Python, .NET 지원

---

## 3. 핵심 개념 5가지

### 3.1 전체 구조 한눈에 보기

```
┌─────────────────────────────────────────────────────────────────────────────┐
│                         Temporal 전체 아키텍처                               │
├─────────────────────────────────────────────────────────────────────────────┤
│                                                                              │
│  ┌─────────────────────────────────────────────────────────────────────┐   │
│  │                      Temporal Server                                 │   │
│  │                                                                      │   │
│  │   역할: 상태 저장, 스케줄링, 재시도 관리                              │   │
│  │   DB: PostgreSQL/MySQL/Cassandra                                    │   │
│  │   포트: 7233 (gRPC)                                                  │   │
│  │                                                                      │   │
│  └───────────────────────────────┬──────────────────────────────────────┘   │
│                                  │                                          │
│                                  │ gRPC (Long Polling)                      │
│                                  │                                          │
│  ┌───────────────────────────────▼──────────────────────────────────────┐   │
│  │                         Worker (Spring Boot)                         │   │
│  │                                                                      │   │
│  │   ┌─────────────────────────────────────────────────────────────┐   │   │
│  │   │                      Workflow                                │   │   │
│  │   │   "비즈니스 로직의 흐름을 정의"                               │   │   │
│  │   │   예: 주문 생성 → 재고 예약 → 결제 처리                       │   │   │
│  │   └─────────────────────────────────────────────────────────────┘   │   │
│  │                              │                                       │   │
│  │                              │ 호출                                  │   │
│  │                              ▼                                       │   │
│  │   ┌─────────────────────────────────────────────────────────────┐   │   │
│  │   │                      Activity                                │   │   │
│  │   │   "실제 작업 수행"                                           │   │   │
│  │   │   예: HTTP 호출, DB 저장, 이메일 발송                         │   │   │
│  │   └────────────────────────────┬────────────────────────────────┘   │   │
│  │                                │                                     │   │
│  └────────────────────────────────┼─────────────────────────────────────┘   │
│                                   │                                         │
│                                   │ HTTP                                    │
│                                   ▼                                         │
│  ┌─────────────────────────────────────────────────────────────────────┐   │
│  │              다른 서비스들 (Order, Inventory, Payment)               │   │
│  └─────────────────────────────────────────────────────────────────────┘   │
│                                                                              │
└─────────────────────────────────────────────────────────────────────────────┘
```

### 3.2 개념 1: Workflow (워크플로우)

> **"비즈니스 프로세스의 흐름을 정의하는 코드"**

**쉬운 비유**: 오케스트라의 **지휘자**

지휘자는 직접 악기를 연주하지 않습니다.
대신 "바이올린 먼저, 그 다음 첼로, 마지막에 팀파니" 이런 식으로 순서를 정합니다.

```java
// Workflow 인터페이스
@WorkflowInterface
public interface OrderWorkflow {

    @WorkflowMethod
    OrderResult processOrder(OrderRequest request);
}

// Workflow 구현
public class OrderWorkflowImpl implements OrderWorkflow {

    @Override
    public OrderResult processOrder(OrderRequest request) {
        // 1단계: 주문 생성 (지휘: "바이올린!")
        Long orderId = activities.createOrder(request);

        // 2단계: 재고 예약 (지휘: "첼로!")
        activities.reserveStock(request.productId());

        // 3단계: 결제 처리 (지휘: "팀파니!")
        activities.processPayment(orderId);

        return OrderResult.success(orderId);
    }
}
```

**Workflow의 핵심 특징:**

| 특징 | 설명 |
|------|------|
| **결정적(Deterministic)** | 같은 입력이면 항상 같은 순서로 실행 |
| **내구성(Durable)** | 서버가 죽어도 상태가 보존됨 |
| **장기 실행 가능** | 몇 초부터 몇 년까지 실행 가능 |

### 3.3 개념 2: Activity (액티비티)

> **"실제 작업을 수행하는 코드"**

**쉬운 비유**: 오케스트라의 **연주자**

연주자는 실제로 악기를 연주합니다. 바이올리니스트가 바이올린을 켜고, 첼리스트가 첼로를 연주합니다.

```java
// Activity 인터페이스
@ActivityInterface
public interface OrderActivities {

    @ActivityMethod
    Long createOrder(Long customerId);

    @ActivityMethod
    void reserveStock(Long productId, int quantity);

    @ActivityMethod
    void processPayment(Long orderId, BigDecimal amount);
}

// Activity 구현
@Component  // ⭐ Spring Bean!
public class OrderActivitiesImpl implements OrderActivities {

    private final RestClient orderClient;

    @Override
    public Long createOrder(Long customerId) {
        // 실제 HTTP 호출!
        return orderClient.post()
            .uri("/api/orders")
            .body(Map.of("customerId", customerId))
            .retrieve()
            .body(OrderResponse.class)
            .getId();
    }

    @Override
    public void reserveStock(Long productId, int quantity) {
        // 실제 HTTP 호출!
        inventoryClient.post()
            .uri("/api/inventory/{id}/reserve", productId)
            .body(Map.of("quantity", quantity))
            .retrieve()
            .toBodilessEntity();
    }
}
```

**Workflow vs Activity 비교:**

```
┌─────────────────────────────────────────────────────────────────────────────┐
│                        Workflow vs Activity                                  │
├──────────────────────────────┬──────────────────────────────────────────────┤
│          Workflow            │                Activity                      │
├──────────────────────────────┼──────────────────────────────────────────────┤
│ 역할: 흐름 제어 (지휘자)      │ 역할: 실제 작업 (연주자)                     │
│                              │                                              │
│ 코드: 결정적이어야 함         │ 코드: 비결정적 허용                          │
│ - new Date() ❌              │ - new Date() ✅                              │
│ - Math.random() ❌           │ - Math.random() ✅                           │
│ - HTTP 호출 ❌               │ - HTTP 호출 ✅                               │
│                              │                                              │
│ 재시도: 상태 복원 후 이어서   │ 재시도: 처음부터 다시                        │
│                              │                                              │
│ Spring DI: ❌ 불가능          │ Spring DI: ✅ 가능 (@Component)              │
│                              │                                              │
│ 생성 주체: Temporal          │ 생성 주체: Spring                            │
└──────────────────────────────┴──────────────────────────────────────────────┘
```

### 3.4 개념 3: Worker (워커)

> **"Workflow와 Activity를 실행하는 프로세스"**

**쉬운 비유**: 오케스트라의 **공연장**

공연장이 없으면 지휘자도 연주자도 연주를 할 수 없습니다.
Worker는 Workflow와 Activity가 실행되는 "무대"입니다.

```java
// Worker 설정 (TemporalConfig.java)
@Bean
public Worker worker(WorkerFactory factory, OrderActivities activities) {

    // 1. Task Queue에서 작업을 가져올 Worker 생성
    Worker worker = factory.newWorker("order-task-queue");

    // 2. Workflow 클래스 등록 (타입만!)
    worker.registerWorkflowImplementationTypes(OrderWorkflowImpl.class);

    // 3. Activity Bean 등록 (인스턴스!)
    worker.registerActivitiesImplementations(activities);

    // 4. 시작 (Long Polling 시작)
    factory.start();

    return worker;
}
```

**Worker의 특징:**

- Temporal Server 외부에서 실행됨 (우리 Spring Boot 앱 안에서)
- 여러 대 띄울 수 있음 (수평 확장)
- Worker가 죽어도 다른 Worker가 이어받음
- Long Polling으로 Task Queue 감시

### 3.5 개념 4: Task Queue (태스크 큐)

> **"Worker가 작업을 가져가는 논리적 대기열"**

**쉬운 비유**: 카페의 **주문 대기표**

손님이 주문하면 대기표가 나오고, 바리스타가 대기표를 보고 음료를 만듭니다.

```
┌─────────────────────────────────────────────────────────────────────────────┐
│                           Task Queue 동작                                    │
├─────────────────────────────────────────────────────────────────────────────┤
│                                                                              │
│   클라이언트: "주문 처리해줘!"                                               │
│        │                                                                    │
│        ▼                                                                    │
│   ┌─────────────────────────────────────────────────────────────────────┐  │
│   │            Task Queue: "order-task-queue"                           │  │
│   │                                                                     │  │
│   │   [Task 1: 주문 ABC]  [Task 2: 주문 DEF]  [Task 3: 주문 GHI]        │  │
│   │                                                                     │  │
│   └────────────────────────────┬────────────────────────────────────────┘  │
│                                │                                            │
│            ┌───────────────────┼───────────────────┐                       │
│            │                   │                   │                       │
│            ▼                   ▼                   ▼                       │
│       Worker 1            Worker 2            Worker 3                     │
│       (서버 A)            (서버 B)            (서버 C)                     │
│                                                                              │
│   효과: 3대의 Worker가 작업을 나눠서 처리 (자동 로드밸런싱)                  │
│                                                                              │
└─────────────────────────────────────────────────────────────────────────────┘
```

### 3.6 개념 5: Signal & Query

> **"실행 중인 Workflow와 상호작용하는 방법"**

**쉬운 비유**:
- Signal = 편지 보내기 (응답 안 기다림)
- Query = 전화 걸기 (응답 기다림)

```
┌─────────────────────────────────────────────────────────────────────────────┐
│                         Signal vs Query                                      │
├──────────────────────────────┬──────────────────────────────────────────────┤
│          Signal              │                Query                         │
├──────────────────────────────┼──────────────────────────────────────────────┤
│ 목적: 상태 변경 요청          │ 목적: 상태 조회                              │
│                              │                                              │
│ 방식: 비동기 (보내고 끝)      │ 방식: 동기 (응답 기다림)                     │
│                              │                                              │
│ 예시: "주문 취소해줘!"        │ 예시: "지금 어디까지 진행됐어?"              │
│                              │                                              │
│ 상태 변경: ✅ 가능            │ 상태 변경: ❌ 불가 (읽기만)                  │
│                              │                                              │
│ 저장: ✅ Event History에 저장 │ 저장: ❌ 저장 안 됨                          │
└──────────────────────────────┴──────────────────────────────────────────────┘
```

---

## 4. Durable Execution 완전 이해

### 4.1 Durable Execution이란?

> **"충돌에도 끄떡없는 실행"** (Crash-proof Execution)

컴퓨터 과학 교수 Flaviu Cristian의 연구에 따르면:
> "실패 처리 코드가 프로덕션 시스템의 2/3 이상을 차지한다"

Durable Execution은 이 문제를 해결합니다.

### 4.2 어떻게 동작하는가?

**핵심 원리: 실행 가상화 (Execution Virtualization)**

```
┌─────────────────────────────────────────────────────────────────────────────┐
│                       실행 가상화의 마법                                     │
├─────────────────────────────────────────────────────────────────────────────┤
│                                                                              │
│  [일반 코드]                                                                │
│                                                                              │
│   프로세스 A에서 실행 시작                                                   │
│        │                                                                    │
│        ▼                                                                    │
│   Step 1: 주문 생성 ✅                                                      │
│   Step 2: 재고 예약 ✅                                                      │
│   Step 3: 결제 처리 중... 💥 (크래시!)                                      │
│                                                                              │
│   → 모든 것이 사라짐. 처음부터 다시.                                         │
│                                                                              │
│  [Temporal 코드]                                                            │
│                                                                              │
│   프로세스 A에서 실행 시작                                                   │
│        │                                                                    │
│        ▼                                                                    │
│   Step 1: 주문 생성 ✅ → Temporal에 기록                                    │
│   Step 2: 재고 예약 ✅ → Temporal에 기록                                    │
│   Step 3: 결제 처리 중... 💥 (크래시!)                                      │
│                                                                              │
│   프로세스 B에서 자동 재개                                                   │
│        │                                                                    │
│        ▼                                                                    │
│   기록 확인: "Step 1, 2 완료됨"                                             │
│   Step 3: 결제 처리 ✅ (이어서!)                                            │
│                                                                              │
└─────────────────────────────────────────────────────────────────────────────┘
```

### 4.3 Durable Execution의 4가지 특성

#### 특성 1: 실행 가상화
- 여러 프로세스에서 순차적으로 실행 가능
- 프로세스가 죽으면 다른 프로세스에서 투명하게 재개

#### 특성 2: 시간 제약 없음
- 초단위 처리부터 수년 단위 실행까지 지원
- `Workflow.sleep(Duration.ofDays(30))` 가능!

#### 특성 3: 자동 상태 보존
- 모든 변수가 자동으로 저장됨
- 별도 데이터베이스 없이 상태 보호

#### 특성 4: 하드웨어 독립성
- 특정 서버에 의존하지 않음
- 어느 Worker에서든 실행 가능

---

## 5. Event History와 Replay

### 5.1 Event History란?

> **"Workflow 실행의 완전한 기록"**

Event History는 **추가 전용 로그(Append-only Log)**입니다.
한 번 기록된 이벤트는 수정되거나 삭제되지 않습니다.

```
┌─────────────────────────────────────────────────────────────────────────────┐
│                    Event History 예시                                        │
├─────────────────────────────────────────────────────────────────────────────┤
│                                                                              │
│  Event ID │ Event Type               │ 상세 정보                            │
│  ─────────┼──────────────────────────┼──────────────────────────────────── │
│     1     │ WorkflowExecutionStarted │ input: {customerId: 1, productId: 2}│
│     2     │ WorkflowTaskScheduled    │                                      │
│     3     │ WorkflowTaskStarted      │                                      │
│     4     │ WorkflowTaskCompleted    │                                      │
│     5     │ ActivityTaskScheduled    │ type: "createOrder"                  │
│     6     │ ActivityTaskStarted      │                                      │
│     7     │ ActivityTaskCompleted    │ result: {orderId: 123}  ⭐ 저장!     │
│     8     │ ActivityTaskScheduled    │ type: "reserveStock"                 │
│     9     │ ActivityTaskStarted      │                                      │
│    10     │ ActivityTaskCompleted    │ result: {success: true} ⭐ 저장!     │
│    ...    │ ...                      │ ...                                  │
│                                                                              │
└─────────────────────────────────────────────────────────────────────────────┘
```

### 5.2 Replay (재생) 메커니즘

> **"Event History를 재생해서 상태를 복구한다"**

```
┌─────────────────────────────────────────────────────────────────────────────┐
│                        Replay 동작 과정                                      │
├─────────────────────────────────────────────────────────────────────────────┤
│                                                                              │
│  [최초 실행]                                                                │
│                                                                              │
│   Workflow 시작                                                              │
│        │                                                                    │
│        ▼                                                                    │
│   activities.createOrder()  → HTTP 호출 → orderId: 123                     │
│   Event History에 기록: ActivityTaskCompleted(result: 123)                  │
│        │                                                                    │
│        ▼                                                                    │
│   activities.reserveStock() → HTTP 호출 → success                          │
│   Event History에 기록: ActivityTaskCompleted(result: success)              │
│        │                                                                    │
│        ▼                                                                    │
│   activities.processPayment() 실행 중... 💥 Worker 크래시!                  │
│                                                                              │
│  ─────────────────────────────────────────────────────────────────────────  │
│                                                                              │
│  [Replay - 새 Worker에서]                                                   │
│                                                                              │
│   Event History 읽기:                                                        │
│   - createOrder 완료됨 (result: 123)                                        │
│   - reserveStock 완료됨 (result: success)                                   │
│                                                                              │
│   Workflow 코드 재실행:                                                      │
│   activities.createOrder()  → HTTP 호출 안 함! 저장된 결과 사용: 123        │
│   activities.reserveStock() → HTTP 호출 안 함! 저장된 결과 사용: success    │
│   activities.processPayment() → 여기서부터 실제 실행!                        │
│                                                                              │
│   ⭐ 핵심: 완료된 Activity는 재호출하지 않음!                                │
│                                                                              │
└─────────────────────────────────────────────────────────────────────────────┘
```

### 5.3 Event History 제한사항

| 제한 | 값 | 발생 시 |
|------|-----|---------|
| 이벤트 개수 경고 | 10,240개 | 경고 발생 |
| 이벤트 개수 제한 | 51,200개 | Workflow 종료 |
| Update 개수 | 2,000개 | Workflow 종료 |
| Signal 개수 | 10,000개 | Workflow 종료 |

**해결책**: Continue-As-New를 사용하여 새 Workflow로 전환

---

## 6. 결정적 코드 규칙

### 6.1 왜 결정적이어야 하는가?

> Replay가 정상 동작하려면, **같은 입력에 항상 같은 결과**가 나와야 합니다.

```
┌─────────────────────────────────────────────────────────────────────────────┐
│                      비결정적 코드의 문제                                    │
├─────────────────────────────────────────────────────────────────────────────┤
│                                                                              │
│  [최초 실행 - 09:00]                                                        │
│                                                                              │
│   if (LocalDateTime.now().getHour() < 10) {  // 09:00 < 10 = true          │
│       activities.processUrgent();  // 긴급 처리                             │
│   } else {                                                                  │
│       activities.processNormal();  // 일반 처리                             │
│   }                                                                          │
│                                                                              │
│   Event History: ActivityTaskScheduled(type: "processUrgent")               │
│                                                                              │
│  [Replay - 10:30]                                                           │
│                                                                              │
│   if (LocalDateTime.now().getHour() < 10) {  // 10:30 < 10 = false ❌       │
│       activities.processUrgent();                                           │
│   } else {                                                                  │
│       activities.processNormal();  // 이쪽으로 가려고 함!                   │
│   }                                                                          │
│                                                                              │
│   💥 Non-Deterministic Error!                                               │
│   "History says processUrgent, but code says processNormal"                 │
│                                                                              │
└─────────────────────────────────────────────────────────────────────────────┘
```

### 6.2 Workflow에서 하면 안 되는 것들

| 금지 항목 | 이유 | 대안 |
|----------|------|------|
| `new Date()`, `LocalDateTime.now()` | Replay마다 다른 값 | `Workflow.currentTimeMillis()` |
| `Math.random()` | Replay마다 다른 값 | `Workflow.newRandom()` |
| `UUID.randomUUID()` | Replay마다 다른 값 | `Workflow.randomUUID()` |
| `Thread.sleep()` | Replay 시 실제로 대기함 | `Workflow.sleep()` |
| HTTP 호출 | Replay마다 다른 결과 가능 | Activity 사용 |
| DB 조회/수정 | Replay마다 다른 결과 가능 | Activity 사용 |
| 파일 읽기/쓰기 | Replay마다 다른 결과 가능 | Activity 사용 |
| 전역 변수 수정 | 예측 불가 | Workflow 내부 변수만 사용 |

### 6.3 올바른 코드 예시

```java
// ❌ 잘못된 코드
public class OrderWorkflowImpl implements OrderWorkflow {

    @Override
    public OrderResult processOrder(OrderRequest request) {
        // 잘못된 예 1: 현재 시간 직접 사용
        if (LocalDateTime.now().getHour() < 9) {
            return OrderResult.failure("영업시간 아님");
        }

        // 잘못된 예 2: 랜덤 사용
        if (Math.random() > 0.5) {
            activities.sendPromotion();
        }

        // 잘못된 예 3: HTTP 직접 호출
        String rate = httpClient.get("/exchange-rate");
    }
}

// ✅ 올바른 코드
public class OrderWorkflowImpl implements OrderWorkflow {

    @Override
    public OrderResult processOrder(OrderRequest request) {
        // 올바른 예 1: Workflow API 사용
        long now = Workflow.currentTimeMillis();
        if (toHour(now) < 9) {
            return OrderResult.failure("영업시간 아님");
        }

        // 올바른 예 2: Activity에서 처리
        boolean shouldSendPromo = activities.checkPromoEligibility();
        if (shouldSendPromo) {
            activities.sendPromotion();
        }

        // 올바른 예 3: Activity 사용
        String rate = activities.getExchangeRate();
    }
}
```

### 6.4 Temporal이 제공하는 결정적 API

```java
// 시간 관련
Workflow.currentTimeMillis()     // 현재 시간 (Replay 안전)
Workflow.sleep(Duration.ofMinutes(5))  // 대기 (Replay 안전)

// 랜덤
Workflow.newRandom()             // Replay 안전한 Random 객체

// UUID
Workflow.randomUUID()            // Replay 안전한 UUID

// 조건 대기
Workflow.await(() -> this.approved)  // 조건 만족까지 대기
Workflow.await(Duration.ofHours(1), () -> this.approved)  // 타임아웃 포함

// 비동기 실행
Promise<T> promise = Async.function(activities::doSomething)
```

---

## 7. Signal, Query, Update

### 7.1 왜 필요한가?

실행 중인 Workflow에 외부에서 개입해야 하는 상황들:

```
[상황 1] 고객이 "주문 취소"를 요청함
         → 실행 중인 Workflow에 "취소해!" 라고 알려야 함
         → Signal 사용

[상황 2] 관리자가 "이 주문 지금 어디까지 진행됐어?"
         → Workflow 상태를 조회해야 함
         → Query 사용

[상황 3] 결제 승인 대기 중, 고객이 카드 정보 변경
         → 새 카드 정보를 전달하고 결과를 확인
         → Update 사용
```

### 7.2 세 가지 메시지 타입 비교

| 구분 | Signal | Query | Update |
|------|--------|-------|--------|
| **목적** | 상태 변경 | 상태 조회 | 상태 변경 + 결과 확인 |
| **방식** | 비동기 | 동기 | 동기 |
| **응답** | 없음 | 있음 | 있음 |
| **상태 변경** | ✅ | ❌ | ✅ |
| **History 저장** | ✅ | ❌ | ✅ |
| **Worker 필요** | 필요 | 필요 | 필요 |

### 7.3 Signal 구현 예시

```java
// 1. Workflow 인터페이스에 Signal 정의
@WorkflowInterface
public interface OrderWorkflow {

    @WorkflowMethod
    OrderResult processOrder(OrderRequest request);

    @SignalMethod
    void cancelOrder(String reason);  // ⭐ Signal!
}

// 2. Workflow 구현에서 Signal 처리
public class OrderWorkflowImpl implements OrderWorkflow {

    private boolean cancelRequested = false;
    private String cancelReason = null;

    @Override
    public OrderResult processOrder(OrderRequest request) {
        Long orderId = activities.createOrder(request);

        // ⭐ Signal 체크 포인트
        if (cancelRequested) {
            activities.cancelOrder(orderId, cancelReason);
            return OrderResult.cancelled(cancelReason);
        }

        activities.reserveStock(request.productId());

        // ⭐ 다시 Signal 체크
        if (cancelRequested) {
            activities.cancelReservation(request.productId());
            activities.cancelOrder(orderId, cancelReason);
            return OrderResult.cancelled(cancelReason);
        }

        activities.processPayment(orderId);
        return OrderResult.success(orderId);
    }

    @Override
    public void cancelOrder(String reason) {
        // Signal 수신 시 상태 변경
        this.cancelRequested = true;
        this.cancelReason = reason;
    }
}

// 3. 외부에서 Signal 보내기
@PostMapping("/orders/{workflowId}/cancel")
public ResponseEntity<?> cancelOrder(@PathVariable String workflowId) {
    OrderWorkflow workflow = workflowClient.newWorkflowStub(
        OrderWorkflow.class, workflowId
    );

    workflow.cancelOrder("고객 요청");  // Signal 전송!

    return ResponseEntity.ok("취소 요청됨");
}
```

### 7.4 Query 구현 예시

```java
// 1. Workflow 인터페이스에 Query 정의
@WorkflowInterface
public interface OrderWorkflow {

    @WorkflowMethod
    OrderResult processOrder(OrderRequest request);

    @QueryMethod
    String getStatus();  // ⭐ Query!

    @QueryMethod
    List<String> getCompletedSteps();  // ⭐ Query!
}

// 2. Workflow 구현에서 Query 응답
public class OrderWorkflowImpl implements OrderWorkflow {

    private String currentStatus = "INITIALIZED";
    private List<String> completedSteps = new ArrayList<>();

    @Override
    public OrderResult processOrder(OrderRequest request) {
        currentStatus = "CREATING_ORDER";
        Long orderId = activities.createOrder(request);
        completedSteps.add("ORDER_CREATED");

        currentStatus = "RESERVING_STOCK";
        activities.reserveStock(request.productId());
        completedSteps.add("STOCK_RESERVED");

        currentStatus = "PROCESSING_PAYMENT";
        activities.processPayment(orderId);
        completedSteps.add("PAYMENT_COMPLETED");

        currentStatus = "COMPLETED";
        return OrderResult.success(orderId);
    }

    @Override
    public String getStatus() {
        return this.currentStatus;  // 읽기만!
    }

    @Override
    public List<String> getCompletedSteps() {
        return new ArrayList<>(this.completedSteps);  // 방어적 복사
    }
}

// 3. 외부에서 Query 호출
@GetMapping("/orders/{workflowId}/status")
public ResponseEntity<?> getStatus(@PathVariable String workflowId) {
    OrderWorkflow workflow = workflowClient.newWorkflowStub(
        OrderWorkflow.class, workflowId
    );

    String status = workflow.getStatus();  // Query!
    List<String> steps = workflow.getCompletedSteps();

    return ResponseEntity.ok(Map.of(
        "status", status,
        "completedSteps", steps
    ));
}
```

### 7.5 Signal + Query 조합 패턴

```java
// 취소 요청 후 상태 확인
@PostMapping("/orders/{workflowId}/cancel")
public ResponseEntity<?> cancelAndWait(@PathVariable String workflowId) {
    OrderWorkflow workflow = workflowClient.newWorkflowStub(
        OrderWorkflow.class, workflowId
    );

    // 1. Signal 전송
    workflow.cancelOrder("고객 요청");

    // 2. Query로 상태 확인 (폴링)
    for (int i = 0; i < 10; i++) {
        String status = workflow.getStatus();
        if ("CANCELLED".equals(status)) {
            return ResponseEntity.ok("취소 완료");
        }
        Thread.sleep(500);
    }

    return ResponseEntity.accepted().body("취소 처리 중...");
}
```

---

## 8. Saga 패턴과 보상 트랜잭션

### 8.1 Saga 패턴이란?

> **"분산 시스템에서 All-or-Nothing을 구현하는 방법"**

기존 데이터베이스의 트랜잭션처럼, 모든 단계가 성공하거나 모든 단계가 취소되어야 합니다.

### 8.2 Saga 패턴의 핵심 아이디어

```
┌─────────────────────────────────────────────────────────────────────────────┐
│                         Saga 패턴의 핵심                                     │
├─────────────────────────────────────────────────────────────────────────────┤
│                                                                              │
│  [성공 시나리오]                                                            │
│                                                                              │
│   T1: 비행기 예약 ✅ ──────────────────────────────────────────────────────▶│
│   T2: 호텔 예약 ✅ ────────────────────────────────────────────────────────▶│
│   T3: 렌터카 예약 ✅ ──────────────────────────────────────────────────────▶│
│                                                                              │
│   모두 성공! 끝.                                                            │
│                                                                              │
│  [실패 시나리오]                                                            │
│                                                                              │
│   T1: 비행기 예약 ✅ ───────┐                                               │
│   T2: 호텔 예약 ✅ ─────────┼───┐                                           │
│   T3: 렌터카 예약 ❌ ───────┼───┼─── 실패!                                  │
│                            │   │                                            │
│   보상 트랜잭션 시작!       │   │                                            │
│   C2: 호텔 취소 ◀──────────┘   │                                            │
│   C1: 비행기 취소 ◀────────────┘                                            │
│                                                                              │
│   모두 취소됨!                                                              │
│                                                                              │
└─────────────────────────────────────────────────────────────────────────────┘
```

### 8.3 Temporal에서 Saga 구현

```java
@Override
public OrderResult processOrder(OrderRequest request) {
    // Saga 객체 생성
    Saga saga = new Saga(new Saga.Options.Builder()
        .setParallelCompensation(false)  // 순차 보상
        .setContinueWithError(true)       // 보상 중 오류 발생해도 계속
        .build());

    Long orderId = null;
    String reservationId = null;
    Long paymentId = null;

    try {
        // ===== 정방향 트랜잭션 =====

        // T1: 주문 생성
        orderId = activities.createOrder(request);
        // 보상 등록: 실패 시 주문 취소
        final Long finalOrderId = orderId;
        saga.addCompensation(() -> activities.cancelOrder(finalOrderId));

        // T2: 재고 "예약" (Semantic Lock - 실제 차감은 나중에)
        reservationId = activities.reserveStock(request.productId(), request.quantity());
        // 보상 등록: 실패 시 예약 취소 (재고 복구)
        final String finalReservationId = reservationId;
        saga.addCompensation(() -> activities.cancelReservation(finalReservationId));

        // T3: 결제 처리
        paymentId = activities.createPayment(orderId, request.amount());
        // 보상 등록: 실패 시 환불
        final Long finalPaymentId = paymentId;
        saga.addCompensation(() -> activities.refundPayment(finalPaymentId));

        // T4: 확정 단계 (보상 등록 없음 - 이 단계에서 실패하면 수동 개입 필요)
        // ★ 재고 예약 → 실제 차감
        activities.confirmReservation(reservationId);
        // ★ 주문 상태 → 확정
        activities.confirmOrder(orderId);

        return OrderResult.success(orderId, paymentId);

    } catch (ActivityFailure e) {
        // ===== 보상 트랜잭션 (자동 역순) =====
        saga.compensate();

        return OrderResult.failure(e.getMessage());
    }
}
```

### 8.4 보상 순서

```
정방향 실행:
T1(주문) → T2(재고예약) → T3(결제) → T4(확정)

실패 시 보상 (역순):
C3(환불) → C2(예약취소) → C1(주문취소)

예시 1: 결제 실패
주문 생성 → 재고 예약 → 결제 처리 (❌ 실패)
                              ↓
                    예약 취소 → 주문 취소

예시 2: 확정 단계 실패 (T4)
주문 생성 → 재고 예약 → 결제 성공 → 확정 (❌ 실패)
                                        ↓
                          Temporal 재시도 → 계속 실패 시 수동 개입 필요
                          (이미 결제됐으므로 단순 보상 불가)
```

> **주의**: 확정 단계(T4)는 보상 등록을 하지 않습니다. 이 단계에서 실패하면
> Temporal이 재시도하고, 그래도 실패하면 운영자가 수동으로 처리해야 합니다.

### 8.5 멱등성의 중요성

> **"같은 작업을 여러 번 실행해도 결과가 동일해야 한다"**

Saga에서 보상 트랜잭션이 재시도될 수 있으므로, 모든 Activity는 멱등성을 가져야 합니다.

```java
// 멱등성 보장 방법
public void refundPayment(Long paymentId, String sagaId) {
    // 1. 멱등성 키 사용
    String idempotencyKey = sagaId + "-refund-" + paymentId;

    // 2. 이미 처리됐는지 확인
    if (isAlreadyProcessed(idempotencyKey)) {
        return;  // 중복 요청 무시
    }

    // 3. 실제 환불 처리
    paymentGateway.refund(paymentId);

    // 4. 처리 완료 기록
    markAsProcessed(idempotencyKey);
}
```

---

## 9. 재시도 정책과 타임아웃

### 9.1 Activity 타임아웃 종류

```
┌─────────────────────────────────────────────────────────────────────────────┐
│                      Activity 타임아웃 종류                                  │
├─────────────────────────────────────────────────────────────────────────────┤
│                                                                              │
│  [StartToCloseTimeout]                                                      │
│                                                                              │
│   Worker가 Activity를 시작한 후 완료까지의 최대 시간                         │
│                                                                              │
│   ──────────────────────────────────────────────────────────────            │
│   │ Activity 시작            Activity 완료                    │            │
│   │──────────────────────────────────────────────────────────│            │
│   │                                                          │            │
│   │◀─────────── StartToCloseTimeout (30초) ─────────────────▶│            │
│   ──────────────────────────────────────────────────────────────            │
│                                                                              │
│  [ScheduleToCloseTimeout]                                                   │
│                                                                              │
│   Activity가 스케줄된 후 완료까지의 최대 시간 (재시도 포함)                   │
│                                                                              │
│   ──────────────────────────────────────────────────────────────            │
│   │ 스케줄링        시작          실패       재시도      완료 │            │
│   │────────────────────────────────────────────────────────│            │
│   │                                                        │            │
│   │◀───────── ScheduleToCloseTimeout (5분) ───────────────▶│            │
│   ──────────────────────────────────────────────────────────────            │
│                                                                              │
│  [ScheduleToStartTimeout]                                                   │
│                                                                              │
│   Activity가 스케줄된 후 Worker가 픽업하기까지의 최대 시간                   │
│                                                                              │
│   ──────────────────────────────────────────────────────────────            │
│   │ 스케줄링                             시작               │            │
│   │────────────────────────────────────────────────────────│            │
│   │                                                        │            │
│   │◀──── ScheduleToStartTimeout (10초) ───────────────────▶│            │
│   ──────────────────────────────────────────────────────────────            │
│                                                                              │
└─────────────────────────────────────────────────────────────────────────────┘
```

### 9.2 재시도 정책 설정

```java
ActivityOptions options = ActivityOptions.newBuilder()
    // 기본 타임아웃
    .setStartToCloseTimeout(Duration.ofSeconds(30))

    // 재시도 정책
    .setRetryOptions(RetryOptions.newBuilder()
        .setInitialInterval(Duration.ofSeconds(1))   // 첫 재시도 대기: 1초
        .setBackoffCoefficient(2.0)                  // 지수 백오프: 1→2→4→8...
        .setMaximumInterval(Duration.ofSeconds(30)) // 최대 대기: 30초
        .setMaximumAttempts(3)                       // 최대 시도: 3번
        .setDoNotRetry(                              // 재시도하지 않을 예외
            IllegalArgumentException.class.getName(),
            InsufficientStockException.class.getName()
        )
        .build())
    .build();
```

### 9.3 재시도 흐름

```
시도 1 → 실패 → 1초 대기
시도 2 → 실패 → 2초 대기  (1 × 2.0)
시도 3 → 실패 → ❌ MaximumAttempts 도달!
                │
                ▼
        ActivityFailure 예외 발생
```

### 9.4 재시도해야 하는 에러 vs 하지 말아야 하는 에러

| 재시도 O | 재시도 X |
|---------|---------|
| 네트워크 타임아웃 | 재고 부족 (InsufficientStock) |
| 일시적 서버 오류 (503) | 잘못된 입력 (IllegalArgument) |
| 데이터베이스 연결 실패 | 비즈니스 규칙 위반 |
| 외부 API 일시 장애 | 인증 실패 |

---

## 10. Spring Boot 통합

### 10.1 의존성 추가

```gradle
// build.gradle
dependencies {
    implementation 'io.temporal:temporal-spring-boot-starter:1.31.0'
}
```

### 10.2 application.yml 설정

```yaml
# 로컬 Temporal Server 연결
spring:
  temporal:
    connection:
      target: localhost:7233
    namespace: default

# 하위 서비스 URL
services:
  order:
    url: http://localhost:21082
  inventory:
    url: http://localhost:21083
  payment:
    url: http://localhost:21084
```

### 10.3 Temporal 설정 클래스

```java
@Configuration
@Slf4j
public class TemporalConfig {

    private static final String TASK_QUEUE = "order-task-queue";

    @Value("${spring.temporal.connection.target}")
    private String temporalTarget;

    @Value("${spring.temporal.namespace}")
    private String namespace;

    // 1. Temporal Server 연결
    @Bean
    public WorkflowServiceStubs workflowServiceStubs() {
        return WorkflowServiceStubs.newServiceStubs(
            WorkflowServiceStubsOptions.newBuilder()
                .setTarget(temporalTarget)
                .build()
        );
    }

    // 2. Workflow Client
    @Bean
    public WorkflowClient workflowClient(WorkflowServiceStubs stubs) {
        return WorkflowClient.newInstance(
            stubs,
            WorkflowClientOptions.newBuilder()
                .setNamespace(namespace)
                .build()
        );
    }

    // 3. Worker Factory
    @Bean
    public WorkerFactory workerFactory(WorkflowClient client) {
        return WorkerFactory.newInstance(client);
    }

    // 4. Worker
    @Bean
    public Worker worker(WorkerFactory factory, OrderActivities activities) {
        Worker worker = factory.newWorker(TASK_QUEUE);

        // Workflow 클래스 등록 (타입만!)
        worker.registerWorkflowImplementationTypes(OrderWorkflowImpl.class);

        // Activity Bean 등록 (인스턴스!)
        worker.registerActivitiesImplementations(activities);

        factory.start();
        return worker;
    }
}
```

### 10.4 Controller에서 Workflow 시작

```java
@RestController
@RequestMapping("/api/orders")
@RequiredArgsConstructor
public class OrderController {

    private final WorkflowClient workflowClient;

    @PostMapping
    public ResponseEntity<OrderResult> createOrder(@RequestBody OrderRequest request) {
        // Workflow ID 생성
        String workflowId = "order-" + UUID.randomUUID().toString().substring(0, 8);

        // Workflow 옵션
        WorkflowOptions options = WorkflowOptions.newBuilder()
            .setTaskQueue("order-task-queue")
            .setWorkflowId(workflowId)
            .setWorkflowExecutionTimeout(Duration.ofMinutes(5))
            .build();

        // Workflow Stub 생성
        OrderWorkflow workflow = workflowClient.newWorkflowStub(
            OrderWorkflow.class, options
        );

        // 동기 실행 (완료까지 대기)
        OrderResult result = workflow.processOrder(request);

        return ResponseEntity.ok(result);
    }

    @PostMapping("/async")
    public ResponseEntity<?> createOrderAsync(@RequestBody OrderRequest request) {
        String workflowId = "order-" + UUID.randomUUID().toString().substring(0, 8);

        WorkflowOptions options = WorkflowOptions.newBuilder()
            .setTaskQueue("order-task-queue")
            .setWorkflowId(workflowId)
            .build();

        OrderWorkflow workflow = workflowClient.newWorkflowStub(
            OrderWorkflow.class, options
        );

        // 비동기 실행 (즉시 반환)
        WorkflowClient.start(workflow::processOrder, request);

        return ResponseEntity.accepted().body(Map.of(
            "workflowId", workflowId,
            "message", "Workflow started"
        ));
    }
}
```

---

## 11. 실전 예제: 주문 처리 Workflow

### 11.1 전체 흐름

```
┌─────────────────────────────────────────────────────────────────────────────┐
│                      주문 처리 Workflow 전체 흐름                            │
├─────────────────────────────────────────────────────────────────────────────┤
│                                                                              │
│  클라이언트                                                                  │
│      │                                                                      │
│      │ POST /api/orders                                                     │
│      ▼                                                                      │
│  Controller ──────────────────────────────────────────────────────────────▶│
│      │                                                                      │
│      │ workflowClient.newWorkflowStub(...)                                 │
│      │ workflow.processOrder(request)                                       │
│      ▼                                                                      │
│  ┌───────────────────────────────────────────────────────────────────────┐ │
│  │                     Temporal Server                                    │ │
│  │                                                                        │ │
│  │  1. Workflow Execution 생성                                           │ │
│  │  2. Event History에 기록: WorkflowExecutionStarted                    │ │
│  │  3. Task Queue에 Task 추가                                            │ │
│  │                                                                        │ │
│  └────────────────────────────────┬──────────────────────────────────────┘ │
│                                   │                                         │
│                                   │ Long Polling                            │
│                                   ▼                                         │
│  ┌───────────────────────────────────────────────────────────────────────┐ │
│  │                     Worker (Spring Boot)                               │ │
│  │                                                                        │ │
│  │  OrderWorkflowImpl.processOrder() 실행:                               │ │
│  │                                                                        │ │
│  │  T1: activities.createOrder() ─────────────▶ Order Service            │ │
│  │      saga.addCompensation(cancelOrder)                                │ │
│  │                                                                        │ │
│  │  T2: activities.reserveStock() ────────────▶ Inventory Service        │ │
│  │      saga.addCompensation(cancelReservation)   (Semantic Lock)        │ │
│  │                                                                        │ │
│  │  T3: activities.processPayment() ──────────▶ Payment Service          │ │
│  │      saga.addCompensation(refundPayment)                              │ │
│  │                                                                        │ │
│  │  T4: 확정 단계 (보상 없음)                                            │ │
│  │      activities.confirmReservation() ──────▶ Inventory Service        │ │
│  │      activities.confirmOrder() ────────────▶ Order Service            │ │
│  │                                                                        │ │
│  │  return OrderResult.success(orderId)                                  │ │
│  │                                                                        │ │
│  └───────────────────────────────────────────────────────────────────────┘ │
│                                                                              │
└─────────────────────────────────────────────────────────────────────────────┘
```

### 11.2 프로젝트 코드 구조

```
orchestrator-temporal/
├── src/main/java/com/hanumoka/orchestrator/temporal/
│   ├── TemporalOrchestratorApplication.java
│   ├── config/
│   │   └── TemporalConfig.java          # Temporal 설정
│   ├── workflow/
│   │   ├── OrderWorkflow.java           # 인터페이스
│   │   └── impl/
│   │       └── OrderWorkflowImpl.java   # 구현체
│   ├── activity/
│   │   ├── OrderActivities.java         # 인터페이스
│   │   └── impl/
│   │       └── OrderActivitiesImpl.java # 구현체 (@Component)
│   ├── controller/
│   │   └── OrderController.java         # REST API
│   └── dto/
│       ├── OrderRequest.java
│       └── OrderResult.java
```

### 11.3 orchestrator-pure vs orchestrator-temporal 비교

| 항목 | orchestrator-pure | orchestrator-temporal |
|------|-------------------|----------------------|
| 코드량 | 167줄 | 164줄 |
| 보상 관리 | 수동 (역순 직접 구현) | 자동 (`saga.addCompensation`) |
| 재시도 | Resilience4j | Temporal RetryOptions |
| 크래시 복구 | ❌ 불가능 | ✅ 자동 |
| 상태 추적 | 로그 뒤져야 함 | Temporal UI에서 확인 |
| 서킷브레이커 | 직접 설정 필요 | Temporal이 관리 |

---

## 참고 자료

- [Temporal 공식 문서](https://docs.temporal.io/)
- [Temporal 블로그 - Durable Execution](https://temporal.io/blog/what-is-durable-execution)
- [Temporal 블로그 - Saga Pattern](https://temporal.io/blog/saga-pattern-made-easy)
- [Spring Boot Integration](https://docs.temporal.io/develop/java/spring-boot-integration)
- [Temporal Java SDK Samples](https://github.com/temporalio/samples-java)

---

## 다음 학습

- [01-temporal-concepts.md](./01-temporal-concepts.md) - 핵심 개념 심화
- [01-temporal-advanced-concepts.md](./01-temporal-advanced-concepts.md) - 고급 개념
- [05-temporal-faq.md](./05-temporal-faq.md) - 자주 묻는 질문
