# 락 전략 통합 가이드 (RLock + Semantic Lock + 낙관적 락)

## 개요

이 문서는 Saga 패턴에서 동시성 제어를 위한 세 가지 락 전략의 관계와 사용법을 정리합니다.

---

## 1. 세 가지 락의 정의

```
┌─────────────────────────────────────────────────────────────────┐
│  세 가지 락 개요                                                 │
├─────────────────────────────────────────────────────────────────┤
│                                                                 │
│  RLock (분산 락)                                                │
│  ├── 정의: Redis 기반 분산 뮤텍스                               │
│  ├── 특성: 물리적 차단 (락 없으면 코드 실행 불가)               │
│  └── 위치: Redis                                                │
│                                                                 │
│  Semantic Lock (의미적 락)                                      │
│  ├── 정의: 데이터에 "작업 중" 상태 기록                         │
│  ├── 특성: 논리적 표시 (개발자가 확인하고 판단)                 │
│  └── 위치: DB (status 컬럼)                                     │
│                                                                 │
│  낙관적 락 (@Version)                                           │
│  ├── 정의: 버전 비교로 충돌 감지                                │
│  ├── 특성: 충돌 감지 후 예외 발생 (재시도 필요)                 │
│  └── 위치: DB (version 컬럼)                                    │
│                                                                 │
└─────────────────────────────────────────────────────────────────┘
```

---

## 2. RLock 범위 설계 - 핵심 질문

### 2.1 Saga 흐름 예시

```
주문 Saga 전체 흐름:
[재고 예약] → [PG 결제(3초)] → [주문 확정] → [재고 확정]
                ~~~~~~~~
                외부 API 호출
                (네트워크, PG 처리)
```

### 2.2 핵심 질문

**"RLock 범위를 어디까지 잡을 것인가?"**

이 질문에 대한 답이 전체 락 전략을 결정합니다.

---

## 3. 설계 선택지

### 3.1 선택 A: RLock 범위 = Saga 전체

```
┌─────────────────────────────────────────────────────────────────┐
│  선택 A: RLock을 Saga 전체에 적용                                │
├─────────────────────────────────────────────────────────────────┤
│                                                                 │
│  RLock ████████████████████████████████████████████ RLock       │
│  획득  │ 예약 │    결제(3초)    │ 확정 │ 확정 │       해제      │
│                                                                 │
│  장점:                                                          │
│  ├── 단순함                                                    │
│  ├── Semantic Lock 불필요                                       │
│  └── 중간 상태 고려 불필요                                      │
│                                                                 │
│  단점:                                                          │
│  ├── 3초+ 동안 다른 모든 요청 블로킹 대기                       │
│  ├── 처리 지연                                                  │
│  ├── 리소스(스레드, Redis 연결) 장기 점유                       │
│  └── 외부 API 장애 시 락 장기 점유                              │
│                                                                 │
└─────────────────────────────────────────────────────────────────┘
```

### 3.2 선택 B: RLock 범위 = 각 DB 작업만

```
┌─────────────────────────────────────────────────────────────────┐
│  선택 B: RLock을 각 DB 작업에만 적용                             │
├─────────────────────────────────────────────────────────────────┤
│                                                                 │
│  RLock ████              (락 없음)             ████ RLock       │
│  획득  │예약│          │ 결제(3초) │          │확정│    해제    │
│                                                                 │
│  장점:                                                          │
│  ├── 락 점유 시간 최소화 (수십 ms)                              │
│  ├── 빠른 응답                                                  │
│  └── 리소스 효율                                                │
│                                                                 │
│  단점:                                                          │
│  ├── 중간 구간 보호 필요                                        │
│  └── Semantic Lock 필요                                         │
│                                                                 │
└─────────────────────────────────────────────────────────────────┘
```

---

## 4. Semantic Lock의 역할

### 4.1 Semantic Lock이란?

```
Semantic Lock = 선택 B에서 RLock이 없는 구간을 보호하기 위한 보완책

본질: 데이터에 "작업 중" 상태를 기록하여
      다른 Saga가 이를 확인하고 판단할 수 있게 함
```

### 4.2 선택 B + Semantic Lock

```
┌─────────────────────────────────────────────────────────────────┐
│  선택 B + Semantic Lock                                          │
├─────────────────────────────────────────────────────────────────┤
│                                                                 │
│  RLock ████              (락 없음)             ████ RLock       │
│  획득  │예약│          │ 결제(3초) │          │확정│    해제    │
│          │                                      │               │
│          ▼                                      ▼               │
│   status='RESERVING'                     status='AVAILABLE'     │
│   sagaId='SAGA-A'                        sagaId=null            │
│                                                                 │
│  ◀────────────── Semantic Lock 보호 구간 ──────────────▶       │
│                                                                 │
│  다른 Saga가 접근 시:                                           │
│  ├── status 확인 → 'RESERVING' 발견                            │
│  ├── "아, 누군가 작업 중이구나"                                │
│  └── 대기 / 재시도 / 거절 중 선택                              │
│                                                                 │
└─────────────────────────────────────────────────────────────────┘
```

### 4.3 Semantic Lock의 실제 가치

**중요: Semantic Lock은 처리량을 향상시키지 않습니다.**

```
┌─────────────────────────────────────────────────────────────────┐
│  같은 상품에 대한 처리량                                         │
├─────────────────────────────────────────────────────────────────┤
│                                                                 │
│  선택 A (RLock 전체):     한 번에 1개 Saga만 처리               │
│  선택 B (Semantic Lock):  한 번에 1개 Saga만 처리               │
│                                                                 │
│  → 처리량 동일                                                  │
│                                                                 │
└─────────────────────────────────────────────────────────────────┘
```

**실제 차이점:**

```
┌─────────────────────────────────────────────────────────────────┐
│  Semantic Lock의 실제 가치                                       │
├─────────────────────────────────────────────────────────────────┤
│                                                                 │
│  1. 빠른 응답 (Fast Fail)                                       │
│     ├── 선택 A: 3초+ 블로킹 대기 후 응답                        │
│     └── 선택 B: 10ms 만에 "작업 중" 확인 후 즉시 응답           │
│                                                                 │
│  2. 정보의 질 향상                                              │
│     ├── Semantic Lock 없음: "재고 부족"                         │
│     └── Semantic Lock 있음: "다른 주문 처리 중"                 │
│     └── 원인을 구분할 수 있음                                   │
│                                                                 │
│  3. 비즈니스 로직 적용 가능                                     │
│     ├── 진짜 부족 → "품절" 안내                                 │
│     └── 작업 중 → "잠시 후 재시도" 안내                         │
│                                                                 │
│  4. 리소스 효율                                                 │
│     ├── 선택 A: 스레드/Redis 연결 3초+ 점유                     │
│     └── 선택 B: 스레드/Redis 연결 10ms 점유                     │
│                                                                 │
└─────────────────────────────────────────────────────────────────┘
```

---

## 5. 두 설계의 정확한 비교

| 구분 | 선택 A (RLock 전체) | 선택 B (RLock + Semantic) |
|------|---------------------|---------------------------|
| 같은 상품 처리량 | 1개/Saga | 1개/Saga (동일) |
| Semantic Lock | 불필요 | 필요 |
| 대기 방식 | 블로킹 (3초+) | 즉시 응답 (10ms) |
| 사용자 응답 시간 | 3초 후 | 즉시 |
| 스레드 점유 | 3초+ | 10ms |
| 비즈니스 로직 | 불가 | 가능 |
| 구현 복잡도 | 단순 | 복잡 |

---

## 6. 낙관적 락 (@Version)의 역할

### 6.1 최후 방어선

```
┌─────────────────────────────────────────────────────────────────┐
│  낙관적 락의 역할                                                │
├─────────────────────────────────────────────────────────────────┤
│                                                                 │
│  정상 상황 (RLock 정상 동작):                                   │
│  └── @Version 발동 안 됨                                        │
│  └── 순차 처리로 충돌 없음                                      │
│                                                                 │
│  비정상 상황 (RLock 실패):                                      │
│  ├── Redis 장애                                                │
│  ├── 개발자 실수 (락 없이 호출)                                │
│  ├── 다른 서비스/배치가 직접 DB 수정                           │
│  └── 네트워크 파티션으로 락 중복 획득                          │
│                                                                 │
│  → @Version이 충돌 감지                                         │
│  → OptimisticLockException 발생                                 │
│  → 재시도로 복구                                                │
│                                                                 │
└─────────────────────────────────────────────────────────────────┘
```

### 6.2 동작 원리

```java
// JPA가 생성하는 SQL
UPDATE inventories
SET quantity = 90,
    reserved_quantity = 10,
    version = 2              -- 버전 증가
WHERE id = 1
  AND version = 1            -- 읽을 때의 버전과 일치해야 함
```

```
Thread A: 읽기 (v=1) → 계산 → UPDATE WHERE v=1 → 성공 (v=2)
Thread B: 읽기 (v=1) → 계산 → UPDATE WHERE v=1 → 실패! (이미 v=2)
                                              → OptimisticLockException
                                              → 재시도
```

---

## 7. 세 가지 락의 역할 분담

```
┌─────────────────────────────────────────────────────────────────┐
│  보호 범위와 역할                                                │
├─────────────────────────────────────────────────────────────────┤
│                                                                 │
│  Saga 흐름:                                                     │
│                                                                 │
│  [예약]        [결제(3초)]        [확정]                        │
│    │               │                │                           │
│    ▼               │                ▼                           │
│  ═════           (없음)           ═════                         │
│  RLock            ↑               RLock                         │
│  (10ms)           │               (10ms)                        │
│                   │                                             │
│  ◀────────────────┴────────────────────▶                       │
│           Semantic Lock (전체 구간)                             │
│           status = RESERVING                                    │
│                                                                 │
│  ──────────────────────────────────────                        │
│  @Version: 모든 UPDATE 시점 (최후 방어선)                       │
│                                                                 │
└─────────────────────────────────────────────────────────────────┘
```

```
┌─────────────────────────────────────────────────────────────────┐
│  각 락의 역할 요약                                               │
├─────────────────────────────────────────────────────────────────┤
│                                                                 │
│  RLock (분산 락)                                                │
│  └── "지금 이 순간" 동시 접근 차단                              │
│  └── DB 읽기/쓰기 작업 보호                                     │
│  └── Semantic Lock 설정/해제 보호                               │
│                                                                 │
│  Semantic Lock (의미적 락)                                      │
│  └── RLock이 없는 구간에서 "작업 중" 정보 제공                  │
│  └── 다른 Saga가 빠르게 상황 파악 가능                          │
│  └── 비즈니스 로직으로 대응 선택 (대기/재시도/거절)             │
│                                                                 │
│  낙관적 락 (@Version)                                           │
│  └── RLock 실패 시 충돌 감지                                    │
│  └── 최후 방어선 (평소에는 발동 안 됨)                          │
│                                                                 │
└─────────────────────────────────────────────────────────────────┘
```

---

## 8. Semantic Lock 전제조건 및 규약

### 8.1 핵심 전제조건: RLock 안에서 설정/해제

```
┌─────────────────────────────────────────────────────────────────┐
│  Semantic Lock 설정 자체가 동시성 문제가 될 수 있음              │
├─────────────────────────────────────────────────────────────────┤
│                                                                 │
│  RLock 없이 Semantic Lock만 설정하면:                           │
│                                                                 │
│  Saga A: status 읽기 → AVAILABLE → status = RESERVING           │
│  Saga B: status 읽기 → AVAILABLE → status = RESERVING           │
│                                                                 │
│  → 둘 다 진행됨 → Semantic Lock 무의미                          │
│                                                                 │
│  해결: Semantic Lock 설정/해제는 반드시 RLock 안에서             │
│                                                                 │
└─────────────────────────────────────────────────────────────────┘
```

### 8.2 전체 규약

| # | 규약 | 목적 |
|---|------|------|
| 1 | RLock 안에서 설정/해제 | 동시 설정 방지 |
| 2 | sagaId 검증 후 해제 | 다른 Saga 락 해제 방지 |
| 3 | 모든 종료 경로에서 해제 | 고아 락 방지 |
| 4 | TTL 설정 (고아 락 대비) | 서버 크래시 시 복구 |
| 5 | 동일 트랜잭션 | 상태 불일치 방지 |
| 6 | 멱등성 보장 | 재시도 안전 |
| 7 | 수량과 상태 함께 처리 | 데이터 일관성 |

### 8.3 규약 상세

#### 규약 1: RLock 안에서 설정/해제

```java
@Transactional
public void reserveStock(Long productId, int quantity, String sagaId) {
    executeWithLock(productId, () -> {  // RLock 획득
        Inventory inventory = getInventory(productId);

        inventory.acquireLock(sagaId);   // Semantic Lock 설정
        inventory.reserve(quantity);

    });  // RLock 해제
}
```

#### 규약 2: sagaId 검증 후 해제

```java
public void releaseLock(String sagaId) {
    if (!sagaId.equals(this.sagaId)) {
        throw new InvalidSagaException("해당 Saga의 락이 아닙니다.");
    }
    this.reservationStatus = ReservationStatus.AVAILABLE;
    this.sagaId = null;
}
```

#### 규약 3: 모든 종료 경로에서 해제

```java
try {
    reserveStock(productId, qty, sagaId);   // 락 설정
    processPayment(...);
    confirmReservation(productId, qty, sagaId);  // 락 해제 (성공)
} catch (Exception e) {
    cancelReservation(productId, qty, sagaId);   // 락 해제 (실패)
    throw e;
}
```

#### 규약 4: TTL 설정 (고아 락 대비)

```java
@Entity
public class Inventory {

    @Column(name = "lock_acquired_at")
    private LocalDateTime lockAcquiredAt;

    private static final Duration LOCK_TTL = Duration.ofMinutes(5);

    public void acquireLock(String sagaId) {
        if (this.reservationStatus == ReservationStatus.RESERVING) {
            if (isLockExpired()) {
                log.warn("고아 락 감지, 강제 해제: {}", this.sagaId);
                forceRelease();
            } else {
                throw new ResourceBusyException("다른 Saga 작업 중");
            }
        }

        this.reservationStatus = ReservationStatus.RESERVING;
        this.sagaId = sagaId;
        this.lockAcquiredAt = LocalDateTime.now();
    }

    public boolean isLockExpired() {
        return lockAcquiredAt != null &&
               LocalDateTime.now().isAfter(lockAcquiredAt.plus(LOCK_TTL));
    }
}
```

#### 규약 6: 멱등성 보장

```java
public void acquireLock(String sagaId) {
    if (this.reservationStatus == ReservationStatus.RESERVING) {
        if (sagaId.equals(this.sagaId)) {
            // 같은 Saga의 재시도 → 이미 락 보유, 통과
            return;
        }
        // 다른 Saga → 에러 또는 만료 체크
    }
    // 락 설정
}
```

---

## 9. 동작 흐름

### 9.1 Saga 정상 흐름

```
┌─────────────────────────────────────────────────────────────────┐
│  [1] 재고 예약                                                  │
│  ┌─────────────────────────────────────┐                       │
│  │ RLock 획득                          │                       │
│  │ status 확인 → AVAILABLE             │                       │
│  │ status = RESERVING, sagaId 설정     │ ← Semantic Lock 설정  │
│  │ lockAcquiredAt = now()              │                       │
│  │ reservedQuantity += 수량            │ ← 비즈니스 로직       │
│  │ RLock 해제                          │                       │
│  └─────────────────────────────────────┘                       │
│                                                                 │
│  [2] 결제 처리 (락 없음)                                        │
│  ┌─────────────────────────────────────┐                       │
│  │ PG API 호출 (3초)                   │ ← Semantic Lock 보호  │
│  └─────────────────────────────────────┘                       │
│                                                                 │
│  [3] 재고 확정                                                  │
│  ┌─────────────────────────────────────┐                       │
│  │ RLock 획득                          │                       │
│  │ sagaId 검증                         │                       │
│  │ confirmReservation()                │ ← 비즈니스 로직       │
│  │ status = AVAILABLE, sagaId = null   │ ← Semantic Lock 해제  │
│  │ RLock 해제                          │                       │
│  └─────────────────────────────────────┘                       │
└─────────────────────────────────────────────────────────────────┘
```

### 9.2 다른 Saga가 접근할 때

```
┌─────────────────────────────────────────────────────────────────┐
│  Saga B가 접근할 때                                              │
├─────────────────────────────────────────────────────────────────┤
│                                                                 │
│  [1] RLock 획득 (10ms 대기)                                     │
│  [2] status 확인 → RESERVING 발견                               │
│  [3] "다른 Saga가 작업 중"                                      │
│  [4] 비즈니스 로직에 따라 선택:                                 │
│      ├── 즉시 거절: "다른 주문 처리 중입니다"                   │
│      ├── 재시도 요청: "잠시 후 다시 시도해주세요"               │
│      └── 대기: TTL 만료 대기 후 재시도                          │
│  [5] RLock 해제                                                 │
│                                                                 │
│  핵심: 10ms 만에 상황 파악 가능 (3초 블로킹 대기 없음)          │
│                                                                 │
└─────────────────────────────────────────────────────────────────┘
```

---

## 10. 최종 정리

```
┌─────────────────────────────────────────────────────────────────┐
│  세 가지 락의 관계                                               │
├─────────────────────────────────────────────────────────────────┤
│                                                                 │
│  [RLock 범위 설계가 먼저]                                       │
│           │                                                     │
│           ├── 선택 A: Saga 전체                                 │
│           │   └── Semantic Lock 불필요                          │
│           │   └── 단순하지만 블로킹 대기                        │
│           │                                                     │
│           └── 선택 B: 각 단계만                                 │
│               └── Semantic Lock 필요                            │
│               └── 빠른 응답, 비즈니스 로직 적용 가능            │
│                                                                 │
│  ─────────────────────────────────────────────────────────────  │
│                                                                 │
│  [Semantic Lock]                                                │
│  └── RLock이 없는 구간을 보호하기 위한 보완책                   │
│  └── 반드시 RLock 안에서 설정/해제                              │
│  └── 처리량 향상 X, 빠른 응답 O, 비즈니스 로직 O                │
│                                                                 │
│  ─────────────────────────────────────────────────────────────  │
│                                                                 │
│  [낙관적 락 @Version]                                           │
│  └── 최후 방어선                                                │
│  └── RLock이 정상 동작하면 발동 안 됨                           │
│  └── RLock 실패 시 충돌 감지                                    │
│                                                                 │
│  ─────────────────────────────────────────────────────────────  │
│                                                                 │
│  [세 가지 락의 목적]                                            │
│  ├── RLock: 동시 접근 차단 (물리적)                            │
│  ├── Semantic Lock: 작업 중 정보 제공 (논리적)                 │
│  └── @Version: 충돌 감지 (최후 방어선)                         │
│                                                                 │
└─────────────────────────────────────────────────────────────────┘
```

---

## 관련 문서

- [04-distributed-lock.md](./04-distributed-lock.md) - RLock 상세
- [05-optimistic-lock.md](./05-optimistic-lock.md) - 낙관적 락 상세
- [11-saga-isolation.md](./11-saga-isolation.md) - Saga Isolation 문제
