# 백엔드 면접 질문지

> 이 문서는 Spring Temporal 학습 프로젝트의 학습 자료를 기반으로 작성된 백엔드 면접 질문지입니다.
> 각 질문에 대해 **이벤트 흐름도**, **시퀀스 다이어그램**, **상태 전이도** 등을 포함하여 상세히 설명합니다.

---

## 목차

1. [분산 시스템 & MSA 아키텍처](#1-분산-시스템--msa-아키텍처)
2. [Saga 패턴](#2-saga-패턴)
3. [멱등성 (Idempotency)](#3-멱등성-idempotency)
4. [동시성 제어](#4-동시성-제어)
5. [Resilience4j - 장애 대응](#5-resilience4j---장애-대응)
6. [Redis & Redisson](#6-redis--redisson)
7. [메시지 큐 (Redis Stream)](#7-메시지-큐-redis-stream)
8. [Temporal](#8-temporal)
9. [Spring 관련](#9-spring-관련)
10. [데이터베이스 & ORM](#10-데이터베이스--orm)
11. [모니터링 & 로깅](#11-모니터링--로깅)
12. [인프라 & DevOps](#12-인프라--devops)

---

## 1. 분산 시스템 & MSA 아키텍처

### Q1-1. 모놀리식과 MSA의 차이점은 무엇인가요?

**모범 답안:**

#### 아키텍처 비교 다이어그램

```
┌─────────────────────────────────────────────────────────────────────────────┐
│                              모놀리식 아키텍처                                │
├─────────────────────────────────────────────────────────────────────────────┤
│                                                                             │
│    ┌─────────────────────────────────────────────────────────────────┐     │
│    │                     Single Application                          │     │
│    │  ┌──────────┐  ┌──────────┐  ┌──────────┐  ┌──────────────┐    │     │
│    │  │  Order   │  │ Inventory│  │ Payment  │  │ Notification │    │     │
│    │  │  Module  │──│  Module  │──│  Module  │──│    Module    │    │     │
│    │  └──────────┘  └──────────┘  └──────────┘  └──────────────┘    │     │
│    │                         │                                       │     │
│    │                         ▼                                       │     │
│    │              ┌─────────────────────┐                           │     │
│    │              │    Single Database  │                           │     │
│    │              │  (ACID Transaction) │                           │     │
│    │              └─────────────────────┘                           │     │
│    └─────────────────────────────────────────────────────────────────┘     │
│                                                                             │
│    장점: 트랜잭션 간단, 디버깅 쉬움                                         │
│    단점: 배포 단위 크고, 확장성 제한                                        │
│                                                                             │
└─────────────────────────────────────────────────────────────────────────────┘

┌─────────────────────────────────────────────────────────────────────────────┐
│                              MSA 아키텍처                                    │
├─────────────────────────────────────────────────────────────────────────────┤
│                                                                             │
│    ┌──────────────┐    ┌──────────────┐    ┌──────────────┐                │
│    │    Order     │    │  Inventory   │    │   Payment    │                │
│    │   Service    │◄──►│   Service    │◄──►│   Service    │                │
│    │              │    │              │    │              │                │
│    │  ┌────────┐  │    │  ┌────────┐  │    │  ┌────────┐  │                │
│    │  │Order DB│  │    │  │Inv. DB │  │    │  │Pay. DB │  │                │
│    │  └────────┘  │    │  └────────┘  │    │  └────────┘  │                │
│    └──────────────┘    └──────────────┘    └──────────────┘                │
│           ▲                   ▲                   ▲                         │
│           └───────────────────┼───────────────────┘                         │
│                               │                                             │
│                    REST / Message Queue                                     │
│                                                                             │
│    장점: 독립 배포/확장, 기술 다양성                                        │
│    단점: 분산 트랜잭션 복잡, 네트워크 지연                                  │
│                                                                             │
└─────────────────────────────────────────────────────────────────────────────┘
```

#### 상세 비교표

| 구분 | 모놀리식 | MSA |
|------|---------|-----|
| 배포 | 전체 배포 (한 번에 모든 기능) | 서비스별 독립 배포 |
| 확장 | 전체 확장 (수직 확장 중심) | 서비스별 개별 확장 (수평 확장) |
| 트랜잭션 | 단일 DB ACID 보장 | 분산 트랜잭션 필요 (Saga) |
| 장애 범위 | 전체 서비스 영향 | 해당 서비스만 영향 (Fault Isolation) |
| 기술 스택 | 단일 기술 | 서비스별 다양한 기술 가능 (Polyglot) |
| 팀 구조 | 기능별 팀 | 서비스별 팀 (Two-Pizza Rule) |

**핵심 포인트:**
- 모놀리식에서 MSA로 전환 시 가장 큰 도전은 **분산 트랜잭션 관리**
- MSA는 "Database per Service" 원칙으로 각 서비스가 자신의 DB 소유
- Conway's Law: 조직 구조가 시스템 아키텍처에 반영됨

---

### Q1-2. MSA에서 분산 트랜잭션이 왜 문제가 되나요?

**모범 답안:**

#### 분산 트랜잭션 문제 시나리오

```
┌─────────────────────────────────────────────────────────────────────────────┐
│                         주문 생성 시나리오                                   │
├─────────────────────────────────────────────────────────────────────────────┤
│                                                                             │
│  Client        Order Service      Inventory Service     Payment Service    │
│    │                │                    │                    │            │
│    │  주문 요청     │                    │                    │            │
│    │───────────────►│                    │                    │            │
│    │                │                    │                    │            │
│    │                │  Step 1: 주문 생성 │                    │            │
│    │                │  ══════════════════│                    │            │
│    │                │  INSERT order      │                    │            │
│    │                │  COMMIT ✓          │                    │            │
│    │                │                    │                    │            │
│    │                │  재고 차감 요청    │                    │            │
│    │                │───────────────────►│                    │            │
│    │                │                    │  Step 2: 재고 차감 │            │
│    │                │                    │  ══════════════════│            │
│    │                │                    │  UPDATE inventory  │            │
│    │                │                    │  COMMIT ✓          │            │
│    │                │                    │                    │            │
│    │                │                    │  결제 요청         │            │
│    │                │                    │───────────────────►│            │
│    │                │                    │                    │            │
│    │                │                    │    Step 3: 결제    │            │
│    │                │                    │    ══════════════  │            │
│    │                │                    │    결제 실패! ✗    │            │
│    │                │                    │                    │            │
│    │                │                    │◄───────────────────│            │
│    │                │◄───────────────────│                    │            │
│    │◄───────────────│                    │                    │            │
│    │                │                    │                    │            │
│    │  ┌─────────────────────────────────────────────────────────────┐      │
│    │  │  문제: Step 1, 2는 이미 커밋됨                              │      │
│    │  │  - Order DB: 주문 데이터 존재                               │      │
│    │  │  - Inventory DB: 재고 차감됨                                │      │
│    │  │  - Payment DB: 결제 기록 없음                               │      │
│    │  │  → 데이터 불일치 발생!                                      │      │
│    │  └─────────────────────────────────────────────────────────────┘      │
│                                                                             │
└─────────────────────────────────────────────────────────────────────────────┘
```

#### 해결 방법 비교

```
┌─────────────────────────────────────────────────────────────────────────────┐
│                           해결 방법 비교                                     │
├─────────────────────────────────────────────────────────────────────────────┤
│                                                                             │
│  1. 2PC (Two-Phase Commit)                                                  │
│  ═══════════════════════════                                                │
│                                                                             │
│     Coordinator                                                             │
│         │                                                                   │
│         │──── Phase 1: Prepare ────►│ All participants                     │
│         │                           │ lock resources                        │
│         │◄─── Vote: Yes/No ─────────│                                       │
│         │                                                                   │
│         │──── Phase 2: Commit ─────►│ If all Yes → Commit                  │
│         │                           │ If any No → Rollback                  │
│                                                                             │
│     문제점:                                                                 │
│     - 동기 블로킹 (성능 저하)                                               │
│     - Coordinator 단일 장애점                                               │
│     - 네트워크 파티션에 취약                                                │
│                                                                             │
│  ─────────────────────────────────────────────────────────────────────────  │
│                                                                             │
│  2. Saga 패턴 (권장)                                                        │
│  ═══════════════════                                                        │
│                                                                             │
│     정상 흐름:                                                              │
│     T1 ──────► T2 ──────► T3 ──────► 완료                                  │
│     (주문)    (재고)    (결제)                                              │
│                                                                             │
│     실패 시 보상 흐름:                                                      │
│     T1 ──────► T2 ──────► T3 ✗                                             │
│                           │                                                 │
│                           ▼                                                 │
│     C1 ◄────── C2 ◄──────┘                                                 │
│     (주문취소) (재고복구)                                                   │
│                                                                             │
│     장점:                                                                   │
│     - 비동기 처리 가능                                                      │
│     - 서비스 자율성 유지                                                    │
│     - 부분 실패 허용                                                        │
│                                                                             │
│  ─────────────────────────────────────────────────────────────────────────  │
│                                                                             │
│  3. Temporal (Saga 자동화)                                                  │
│  ═════════════════════════                                                  │
│                                                                             │
│     - Saga 상태 자동 관리                                                   │
│     - 실패 시 자동 보상                                                     │
│     - 서버 다운 후 자동 재개                                                │
│     - 재시도 정책 선언적 설정                                               │
│                                                                             │
└─────────────────────────────────────────────────────────────────────────────┘
```

---

### Q1-3. CAP 정리에 대해 설명해주세요.

**모범 답안:**

#### CAP 정리 다이어그램

```
┌─────────────────────────────────────────────────────────────────────────────┐
│                              CAP 정리                                        │
├─────────────────────────────────────────────────────────────────────────────┤
│                                                                             │
│                         C (Consistency)                                     │
│                        일관성: 모든 노드가                                   │
│                        같은 데이터를 본다                                    │
│                              /\                                             │
│                             /  \                                            │
│                            /    \                                           │
│                           / CA   \                                          │
│                          / 단일DB \                                         │
│                         /  RDBMS   \                                        │
│                        /────────────\                                       │
│                       /              \                                      │
│                      /   불가능한     \                                     │
│                     /     영역        \                                     │
│                    /   (3개 동시에     \                                    │
│                   /    만족 불가)      \                                    │
│                  /                      \                                   │
│           CP   /                        \  CP                               │
│        MongoDB/                          \HBase                             │
│              /                            \                                 │
│             /──────────────────────────────\                                │
│            A (Availability)     P (Partition Tolerance)                     │
│         가용성: 모든 요청이    분할 허용: 네트워크 분할                      │
│         응답을 받음            상황에서도 동작                               │
│                                                                             │
│                         AP                                                  │
│                    Cassandra                                                │
│                    DynamoDB                                                 │
│                                                                             │
└─────────────────────────────────────────────────────────────────────────────┘
```

#### 실제 선택 시나리오

```
┌─────────────────────────────────────────────────────────────────────────────┐
│                        네트워크 파티션 발생 시                               │
├─────────────────────────────────────────────────────────────────────────────┤
│                                                                             │
│     [Node A]                    ✗ 네트워크 단절 ✗                [Node B]   │
│        │                                                            │       │
│        │  클라이언트 요청: "잔액 조회"                              │       │
│        │                                                            │       │
│  ┌─────┴─────────────────────────────────────────────────────────────┴────┐ │
│  │                                                                        │ │
│  │  CP 선택 (일관성 우선) - 금융 시스템                                   │ │
│  │  ═══════════════════════════════════                                   │ │
│  │                                                                        │ │
│  │  [Node A]: "다른 노드와 통신 불가, 요청 거부" → 503 Error              │ │
│  │  [Node B]: "다른 노드와 통신 불가, 요청 거부" → 503 Error              │ │
│  │                                                                        │ │
│  │  결과: 서비스 불가하지만, 잘못된 잔액 표시 방지                        │ │
│  │                                                                        │ │
│  └────────────────────────────────────────────────────────────────────────┘ │
│                                                                             │
│  ┌────────────────────────────────────────────────────────────────────────┐ │
│  │                                                                        │ │
│  │  AP 선택 (가용성 우선) - 쇼핑몰, SNS                                   │ │
│  │  ═════════════════════════════════════                                 │ │
│  │                                                                        │ │
│  │  [Node A]: 잔액 = 10,000원 (최신)                                      │ │
│  │  [Node B]: 잔액 = 8,000원 (구버전)  ← Stale Read 허용                  │ │
│  │                                                                        │ │
│  │  결과: 서비스 가능하지만, 일시적으로 다른 값 표시                      │ │
│  │        → 나중에 동기화 (Eventual Consistency)                          │ │
│  │                                                                        │ │
│  └────────────────────────────────────────────────────────────────────────┘ │
│                                                                             │
└─────────────────────────────────────────────────────────────────────────────┘
```

**핵심 포인트:**
- 실제로는 P(분할 허용)를 포기할 수 없음 → **CP vs AP 선택**
- 우리 프로젝트: **AP 선호** (가용성 우선, 최종 일관성)
- PACELC 정리: 파티션 없을 때도 Latency vs Consistency 트레이드오프

---

### Q1-4. 멀티모듈 프로젝트에서 순환 참조를 어떻게 방지하나요?

**모범 답안:**

#### 모듈 의존성 구조

```
┌─────────────────────────────────────────────────────────────────────────────┐
│                      멀티모듈 의존성 구조                                    │
├─────────────────────────────────────────────────────────────────────────────┤
│                                                                             │
│  레벨 3 (최상위)                                                            │
│  ┌─────────────────────────────────────────────────────────────────────┐   │
│  │                    orchestrator-pure                                 │   │
│  │                    orchestrator-temporal                             │   │
│  │                                                                      │   │
│  │  역할: Saga 조율, 워크플로우 관리                                    │   │
│  │  의존: services, common                                              │   │
│  └─────────────────────────────────────────────────────────────────────┘   │
│                              │                                              │
│                              │ depends on                                   │
│                              ▼                                              │
│  레벨 2 (중간)                                                              │
│  ┌────────────┐ ┌────────────┐ ┌────────────┐ ┌────────────────────────┐   │
│  │  service-  │ │  service-  │ │  service-  │ │     service-           │   │
│  │   order    │ │ inventory  │ │  payment   │ │    notification        │   │
│  │            │ │            │ │            │ │                        │   │
│  │ 역할:      │ │ 역할:      │ │ 역할:      │ │ 역할:                  │   │
│  │ 주문 관리  │ │ 재고 관리  │ │ 결제 처리  │ │ 알림 발송              │   │
│  └────────────┘ └────────────┘ └────────────┘ └────────────────────────┘   │
│         │              │              │                   │                 │
│         │              │              │                   │                 │
│         └──────────────┴──────────────┴───────────────────┘                 │
│                              │                                              │
│                              │ depends on                                   │
│                              ▼                                              │
│  레벨 1 (최하위)                                                            │
│  ┌─────────────────────────────────────────────────────────────────────┐   │
│  │                           common                                     │   │
│  │                                                                      │   │
│  │  포함: DTO, Event, Exception, Constants                             │   │
│  │  의존: 외부 라이브러리만 (다른 모듈 의존 금지!)                      │   │
│  └─────────────────────────────────────────────────────────────────────┘   │
│                                                                             │
│  ═══════════════════════════════════════════════════════════════════════   │
│                                                                             │
│  ✗ 금지 패턴:                                                               │
│                                                                             │
│     service-order ──────► service-inventory                                 │
│           ▲                      │                                          │
│           └──────────────────────┘   ← 순환 참조!                           │
│                                                                             │
│  ✓ 허용 패턴:                                                               │
│                                                                             │
│     service-order ──────► common ◄────── service-inventory                  │
│                      (공통 인터페이스 통해 통신)                             │
│                                                                             │
└─────────────────────────────────────────────────────────────────────────────┘
```

#### ArchUnit 테스트로 의존성 검증

```java
// ArchUnit 테스트 예시
@AnalyzeClasses(packages = "com.example")
class ArchitectureTest {

    @ArchTest
    static final ArchRule commonShouldNotDependOnServices =
        noClasses()
            .that().resideInAPackage("..common..")
            .should().dependOnClassesThat()
            .resideInAnyPackage("..service..", "..orchestrator..");

    @ArchTest
    static final ArchRule servicesShouldNotDependOnOrchestrator =
        noClasses()
            .that().resideInAPackage("..service..")
            .should().dependOnClassesThat()
            .resideInAPackage("..orchestrator..");

    @ArchTest
    static final ArchRule servicesShouldNotDependOnEachOther =
        slices()
            .matching("..service.(*)..")
            .should().notDependOnEachOther();
}
```

---

## 2. Saga 패턴

### Q2-1. Saga 패턴이 무엇이고, 왜 필요한가요?

**모범 답안:**

**정의:** 분산 트랜잭션을 여러 개의 **로컬 트랜잭션**과 **보상 트랜잭션**으로 분리하여 관리하는 패턴

#### Saga 실행 흐름 다이어그램

```
┌─────────────────────────────────────────────────────────────────────────────┐
│                         Saga 정상 실행 흐름                                  │
├─────────────────────────────────────────────────────────────────────────────┤
│                                                                             │
│  시간 ──────────────────────────────────────────────────────────────────►   │
│                                                                             │
│     T1              T2              T3              완료                    │
│  ┌──────┐        ┌──────┐        ┌──────┐        ┌──────┐                  │
│  │주문  │───────►│재고  │───────►│결제  │───────►│ 성공 │                  │
│  │생성  │        │차감  │        │처리  │        │      │                  │
│  └──────┘        └──────┘        └──────┘        └──────┘                  │
│     │               │               │                                       │
│     │ COMMIT        │ COMMIT        │ COMMIT                                │
│     ▼               ▼               ▼                                       │
│  [Order DB]     [Inventory DB]  [Payment DB]                                │
│                                                                             │
│  상태: CREATED → RESERVED → PAID → COMPLETED                                │
│                                                                             │
└─────────────────────────────────────────────────────────────────────────────┘

┌─────────────────────────────────────────────────────────────────────────────┐
│                         Saga 실패 시 보상 흐름                               │
├─────────────────────────────────────────────────────────────────────────────┤
│                                                                             │
│  시간 ──────────────────────────────────────────────────────────────────►   │
│                                                                             │
│     T1              T2              T3                                      │
│  ┌──────┐        ┌──────┐        ┌──────┐                                  │
│  │주문  │───────►│재고  │───────►│결제  │                                  │
│  │생성  │        │차감  │        │처리  │                                  │
│  └──────┘        └──────┘        └──┬───┘                                  │
│     │               │               │                                       │
│     │ COMMIT ✓      │ COMMIT ✓      │ FAILED ✗                             │
│     │               │               │                                       │
│     │               │               │  결제 실패 감지!                      │
│     │               │               │                                       │
│     │               │       ┌───────┘                                       │
│     │               │       │                                               │
│     │               │       ▼  보상 트랜잭션 시작                           │
│     │               │                                                       │
│     │     C2        │       │                                               │
│     │  ┌──────┐     │◄──────┘                                               │
│     │  │재고  │◄────┘                                                       │
│     │  │복구  │                                                             │
│     │  └──────┘                                                             │
│     │     │                                                                 │
│     │     │ COMMIT ✓ (보상)                                                 │
│     │     │                                                                 │
│     │     │     C1                                                          │
│     │  ┌──┴───┐                                                             │
│     │  │주문  │◄───────────────────────────────────────────                 │
│     └─►│취소  │                                                             │
│        └──────┘                                                             │
│           │                                                                 │
│           │ COMMIT ✓ (보상)                                                 │
│           ▼                                                                 │
│        [최종 상태: CANCELLED]                                               │
│                                                                             │
│  ═══════════════════════════════════════════════════════════════════════   │
│  보상 순서: 역순 실행 (T3 실패 → C2 → C1)                                   │
│  ═══════════════════════════════════════════════════════════════════════   │
│                                                                             │
└─────────────────────────────────────────────────────────────────────────────┘
```

#### Saga가 필요한 이유

```
┌─────────────────────────────────────────────────────────────────────────────┐
│                        왜 Saga가 필요한가?                                   │
├─────────────────────────────────────────────────────────────────────────────┤
│                                                                             │
│  모놀리식: 하나의 트랜잭션으로 처리                                         │
│  ════════════════════════════════════                                       │
│                                                                             │
│     @Transactional                                                          │
│     public void createOrder() {                                             │
│         orderRepository.save(order);      // 하나의 트랜잭션                │
│         inventoryRepository.decrease();   // 안에서 모두 처리               │
│         paymentRepository.charge();       //                                │
│     }  // COMMIT 또는 ROLLBACK (전체)                                       │
│                                                                             │
│  ─────────────────────────────────────────────────────────────────────────  │
│                                                                             │
│  MSA: 각 서비스가 독립 DB를 가짐                                            │
│  ════════════════════════════════                                           │
│                                                                             │
│     [Order Service]         [Inventory Service]      [Payment Service]      │
│           │                        │                        │               │
│     ┌─────┴─────┐            ┌─────┴─────┐            ┌─────┴─────┐        │
│     │ Order DB  │            │  Inv. DB  │            │ Pay. DB   │        │
│     └───────────┘            └───────────┘            └───────────┘        │
│                                                                             │
│     각 DB는 독립적 → @Transactional이 여러 DB를 묶을 수 없음!               │
│                                                                             │
│     → Saga 패턴으로 로컬 트랜잭션 + 보상 트랜잭션 조합                      │
│                                                                             │
└─────────────────────────────────────────────────────────────────────────────┘
```

---

### Q2-2. Orchestration과 Choreography의 차이점은 무엇인가요?

**모범 답안:**

#### 두 방식의 시각적 비교

```
┌─────────────────────────────────────────────────────────────────────────────┐
│                    Orchestration (중앙 집중식)                               │
├─────────────────────────────────────────────────────────────────────────────┤
│                                                                             │
│                       ┌─────────────────────┐                               │
│                       │    Orchestrator     │                               │
│                       │  (Saga Coordinator) │                               │
│                       │                     │                               │
│                       │  1. 주문 생성 명령  │                               │
│                       │  2. 재고 차감 명령  │                               │
│                       │  3. 결제 처리 명령  │                               │
│                       │                     │                               │
│                       │  [전체 흐름 파악]   │                               │
│                       └──────────┬──────────┘                               │
│                                  │                                          │
│              ┌───────────────────┼───────────────────┐                      │
│              │                   │                   │                      │
│              ▼                   ▼                   ▼                      │
│       ┌──────────┐        ┌──────────┐        ┌──────────┐                 │
│       │  Order   │        │ Inventory│        │ Payment  │                 │
│       │ Service  │        │ Service  │        │ Service  │                 │
│       └──────────┘        └──────────┘        └──────────┘                 │
│                                                                             │
│   장점:                                                                     │
│   - 전체 흐름을 한 곳에서 파악                                              │
│   - 디버깅/모니터링 용이                                                    │
│   - Temporal과 자연스러운 연동                                              │
│                                                                             │
│   단점:                                                                     │
│   - Orchestrator에 로직 집중                                                │
│   - 단일 장애점 가능성                                                      │
│                                                                             │
└─────────────────────────────────────────────────────────────────────────────┘

┌─────────────────────────────────────────────────────────────────────────────┐
│                    Choreography (이벤트 기반)                                │
├─────────────────────────────────────────────────────────────────────────────┤
│                                                                             │
│                        Event Bus / Message Queue                            │
│   ═══════════════════════════════════════════════════════════════════════  │
│         ▲           │         ▲           │         ▲           │          │
│         │           ▼         │           ▼         │           ▼          │
│   ┌─────┴────┐ ┌─────────┐ ┌─┴───────┐ ┌────────┐ ┌┴────────┐ ┌────────┐  │
│   │  Order   │ │OrderCreated│ Inventory │ StockReserved│ Payment │ PaymentDone│
│   │ Service  │ │  Event   │ │ Service │ │  Event  │ │ Service │ │  Event │  │
│   │          │ └─────────┘ │         │ └────────┘ │         │ └────────┘  │
│   │ 1.주문생성│             │ 2.재고차감│            │ 3.결제처리│           │
│   └──────────┘             └─────────┘            └─────────┘             │
│        │                        │                       │                  │
│        │ 이벤트 발행            │ 이벤트 구독/발행      │ 이벤트 구독      │
│        └────────────────────────┴───────────────────────┘                  │
│                                                                             │
│   장점:                                                                     │
│   - 느슨한 결합                                                             │
│   - 서비스 독립성 높음                                                      │
│   - 확장 용이                                                               │
│                                                                             │
│   단점:                                                                     │
│   - 전체 흐름 파악 어려움 (이벤트 추적 필요)                                │
│   - 사이클 발생 가능                                                        │
│   - 디버깅 복잡                                                             │
│                                                                             │
└─────────────────────────────────────────────────────────────────────────────┘
```

#### 상세 비교표

| 구분 | Orchestration | Choreography |
|------|---------------|--------------|
| 제어 방식 | 중앙 오케스트레이터가 조율 | 각 서비스가 이벤트 기반 자율 동작 |
| 흐름 파악 | 오케스트레이터에서 한눈에 파악 | 여러 서비스 로그 추적 필요 |
| 결합도 | 오케스트레이터에 의존 | 느슨한 결합 |
| 복잡도 | 서비스 증가해도 관리 용이 | 서비스 증가 시 이벤트 복잡 |
| 실무 사용 비율 | **70-80%** (금융, 주문 등) | 20-30% (단순 이벤트 전파) |
| 적합한 경우 | 복잡한 비즈니스 로직 | 단순 이벤트 알림 |

**Orchestration 선택 이유:**
1. 비즈니스 흐름 명확 (디버깅 용이)
2. Temporal과 자연스러운 연동
3. 실무에서 더 많이 사용 (Uber, Netflix)

---

### Q2-3. 보상 트랜잭션 설계 시 주의할 점은 무엇인가요?

**모범 답안:**

#### 보상 트랜잭션 설계 원칙

```
┌─────────────────────────────────────────────────────────────────────────────┐
│                      보상 트랜잭션 설계 4대 원칙                             │
├─────────────────────────────────────────────────────────────────────────────┤
│                                                                             │
│  1. 멱등성 보장 (Idempotency)                                               │
│  ═══════════════════════════════                                            │
│                                                                             │
│     보상 트랜잭션이 여러 번 호출되어도 같은 결과                            │
│                                                                             │
│     호출 1: 재고 복구 (99 → 100) ✓                                          │
│     호출 2: 재고 복구 (100 → 100) ✓  ← 이미 복구됨, 무시                   │
│     호출 3: 재고 복구 (100 → 100) ✓  ← 이미 복구됨, 무시                   │
│                                                                             │
│  ─────────────────────────────────────────────────────────────────────────  │
│                                                                             │
│  2. 역순 실행 (Reverse Order)                                               │
│  ════════════════════════════════                                           │
│                                                                             │
│     정상 흐름:  T1 ────► T2 ────► T3                                        │
│                 │        │        │                                         │
│                 ▼        ▼        ▼                                         │
│     보상 흐름:  C1 ◄──── C2 ◄──── C3  (역순!)                               │
│                                                                             │
│     이유: 의존성 역순으로 해제해야 일관성 유지                              │
│                                                                             │
│  ─────────────────────────────────────────────────────────────────────────  │
│                                                                             │
│  3. 시맨틱 롤백 (Semantic Undo)                                             │
│  ═══════════════════════════════                                            │
│                                                                             │
│     ✗ 나쁜 예: 데이터 물리 삭제                                             │
│     ─────────────────────────────                                           │
│     DELETE FROM orders WHERE id = ?                                         │
│     → 감사 추적 불가, 복구 불가                                             │
│                                                                             │
│     ✓ 좋은 예: 상태 변경 (논리 삭제)                                        │
│     ─────────────────────────────────                                       │
│     UPDATE orders SET status = 'CANCELLED',                                 │
│                        cancelled_at = NOW(),                                │
│                        cancel_reason = '결제 실패'                          │
│     WHERE id = ?                                                            │
│     → 이력 추적 가능, 분석 가능                                             │
│                                                                             │
│  ─────────────────────────────────────────────────────────────────────────  │
│                                                                             │
│  4. 실패 허용 (Failure Tolerance)                                           │
│  ═════════════════════════════════                                          │
│                                                                             │
│     보상 C2 실패해도 C1은 계속 진행                                         │
│                                                                             │
│     T1 ─► T2 ─► T3 ✗                                                        │
│           │                                                                 │
│           ▼                                                                 │
│     C1 ◄─ C2 ✗ (실패)                                                       │
│      │                                                                      │
│      │   ┌─────────────────────────────────┐                                │
│      │   │ C2 실패 → Dead Letter Queue     │                                │
│      │   │ → 나중에 수동/자동 재처리       │                                │
│      │   └─────────────────────────────────┘                                │
│      │                                                                      │
│      ▼                                                                      │
│     C1 ✓ (계속 진행)                                                        │
│                                                                             │
└─────────────────────────────────────────────────────────────────────────────┘
```

---

### Q2-4. Saga의 격리성(Isolation) 문제는 어떻게 해결하나요?

**모범 답안:**

**문제:** Saga는 ACID의 I(Isolation)를 보장하지 않음

#### Dirty Read 문제 시나리오

```
┌─────────────────────────────────────────────────────────────────────────────┐
│                      Saga 격리성 문제: Dirty Read                            │
├─────────────────────────────────────────────────────────────────────────────┤
│                                                                             │
│  시간 ──────────────────────────────────────────────────────────────────►   │
│                                                                             │
│  사용자 A:                                                                  │
│  ┌──────────────────────────────────────────────────────────────────────┐  │
│  │ 주문 시작       재고 차감          결제 시도         결제 실패!      │  │
│  │     │              │                  │                  │           │  │
│  │     ▼              ▼                  ▼                  ▼           │  │
│  │ 재고: 100      재고: 99           처리중...        재고 복구→100    │  │
│  │                    │                                     │           │  │
│  └────────────────────┼─────────────────────────────────────┼───────────┘  │
│                       │                                     │              │
│                       │    ← 이 시점에 사용자 B가 조회 →    │              │
│                       │                                     │              │
│  사용자 B:            ▼                                     │              │
│  ┌────────────────────────────────────────────────────────────────────┐    │
│  │              재고 조회                                              │    │
│  │                  │                                                  │    │
│  │                  ▼                                                  │    │
│  │              재고: 99개                                             │    │
│  │                  │                                                  │    │
│  │                  ▼                                                  │    │
│  │         "99개니까 100개 주문 불가"  ← Dirty Read!                   │    │
│  │         (실제로는 곧 100개로 복구됨)                                │    │
│  │                                                                     │    │
│  └─────────────────────────────────────────────────────────────────────┘   │
│                                                                             │
└─────────────────────────────────────────────────────────────────────────────┘
```

#### 해결 전략

```
┌─────────────────────────────────────────────────────────────────────────────┐
│                         격리성 문제 해결 전략                                │
├─────────────────────────────────────────────────────────────────────────────┤
│                                                                             │
│  1. Semantic Lock (의미적 잠금)                                             │
│  ═════════════════════════════════                                          │
│                                                                             │
│     재고 테이블 구조:                                                       │
│     ┌──────────────────────────────────────────────┐                       │
│     │ product_id │ quantity │ reserved │ available │                       │
│     │     1      │   100    │    5     │    95     │                       │
│     └──────────────────────────────────────────────┘                       │
│                                                                             │
│     -- 재고 차감 대신 "예약" 상태로 관리                                    │
│     UPDATE inventory                                                        │
│     SET reserved = reserved + 1                                             │
│     WHERE product_id = ? AND (quantity - reserved) >= 1;                    │
│                                                                             │
│     available = quantity - reserved (가상 컬럼)                             │
│                                                                             │
│  ─────────────────────────────────────────────────────────────────────────  │
│                                                                             │
│  2. Commutative Updates (교환 가능 업데이트)                                │
│  ═════════════════════════════════════════════                              │
│                                                                             │
│     ✗ 나쁜 예: 절대값 업데이트                                              │
│     UPDATE inventory SET quantity = 99 WHERE product_id = ?                 │
│                                                                             │
│     ✓ 좋은 예: 상대값 업데이트                                              │
│     UPDATE inventory SET quantity = quantity - 1 WHERE product_id = ?       │
│                                                                             │
│     장점: 순서와 관계없이 결과 동일                                         │
│     A: -1, B: -2 = B: -2, A: -1 (교환 법칙 성립)                            │
│                                                                             │
│  ─────────────────────────────────────────────────────────────────────────  │
│                                                                             │
│  3. Pessimistic View (비관적 뷰)                                            │
│  ═══════════════════════════════                                            │
│                                                                             │
│     API 응답 예시:                                                          │
│     {                                                                       │
│       "productId": 1,                                                       │
│       "quantity": 99,                                                       │
│       "pendingSagas": 3,     ← 진행 중인 Saga 수                           │
│       "warning": "3건의 주문이 진행 중입니다. 재고 변동 가능"              │
│     }                                                                       │
│                                                                             │
│  ─────────────────────────────────────────────────────────────────────────  │
│                                                                             │
│  4. Version Check (낙관적 락)                                               │
│  ════════════════════════════                                               │
│                                                                             │
│     UPDATE inventory                                                        │
│     SET quantity = quantity - 1, version = version + 1                      │
│     WHERE product_id = ? AND version = ?;                                   │
│                                                                             │
│     affected_rows = 0 → 충돌 감지 → 재시도                                  │
│                                                                             │
└─────────────────────────────────────────────────────────────────────────────┘
```

---

## 3. 멱등성 (Idempotency)

### Q3-1. 멱등성이 무엇이고, 왜 중요한가요?

**모범 답안:**

**정의:** 같은 요청을 여러 번 실행해도 결과가 동일한 성질

#### 멱등성이 없을 때 발생하는 문제

```
┌─────────────────────────────────────────────────────────────────────────────┐
│                        이중 결제 문제 시나리오                               │
├─────────────────────────────────────────────────────────────────────────────┤
│                                                                             │
│  Client                    Server                     Payment Gateway       │
│    │                         │                              │               │
│    │  1. POST /payment       │                              │               │
│    │  {amount: 10000}        │                              │               │
│    │────────────────────────►│                              │               │
│    │                         │                              │               │
│    │                         │  2. 결제 요청                │               │
│    │                         │─────────────────────────────►│               │
│    │                         │                              │               │
│    │                         │  3. 결제 성공                │               │
│    │                         │◄─────────────────────────────│               │
│    │                         │                              │               │
│    │                    4. 응답 전송 중...                  │               │
│    │◄ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ✗ 네트워크 끊김!               │               │
│    │                         │                              │               │
│    │  5. 타임아웃 (5초)      │                              │               │
│    │  클라이언트 재시도      │                              │               │
│    │                         │                              │               │
│    │  6. POST /payment       │                              │               │
│    │  {amount: 10000}        │                              │               │
│    │────────────────────────►│                              │               │
│    │                         │                              │               │
│    │                         │  7. 또 결제 요청!            │               │
│    │                         │─────────────────────────────►│               │
│    │                         │                              │               │
│    │                         │  8. 또 결제 성공             │               │
│    │                         │◄─────────────────────────────│               │
│    │                         │                              │               │
│    │  9. 성공 응답           │                              │               │
│    │◄────────────────────────│                              │               │
│    │                         │                              │               │
│    │  ┌─────────────────────────────────────────────────────────────┐      │
│    │  │  결과: 10,000원 × 2 = 20,000원 결제됨!                      │      │
│    │  │  → 이중 결제 발생                                           │      │
│    │  └─────────────────────────────────────────────────────────────┘      │
│                                                                             │
└─────────────────────────────────────────────────────────────────────────────┘
```

#### 멱등성 키로 해결

```
┌─────────────────────────────────────────────────────────────────────────────┐
│                      멱등성 키(Idempotency Key) 해결                         │
├─────────────────────────────────────────────────────────────────────────────┤
│                                                                             │
│  Client                    Server                                           │
│    │                         │                                              │
│    │  1. POST /payment       │                                              │
│    │  X-Idempotency-Key: abc123                                             │
│    │  {amount: 10000}        │                                              │
│    │────────────────────────►│                                              │
│    │                         │                                              │
│    │                         │  ┌─────────────────────────────────────┐    │
│    │                         │  │ 2. 키 확인: abc123 존재?            │    │
│    │                         │  │    → 없음, 새 요청                  │    │
│    │                         │  │    → 키 저장 + 결제 처리            │    │
│    │                         │  │    → 결과 저장                      │    │
│    │                         │  └─────────────────────────────────────┘    │
│    │                         │                                              │
│    │◄ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ✗ 네트워크 끊김                                │
│    │                         │                                              │
│    │  3. 재시도               │                                              │
│    │  X-Idempotency-Key: abc123  (같은 키!)                                 │
│    │  {amount: 10000}        │                                              │
│    │────────────────────────►│                                              │
│    │                         │                                              │
│    │                         │  ┌─────────────────────────────────────┐    │
│    │                         │  │ 4. 키 확인: abc123 존재?            │    │
│    │                         │  │    → 있음! 중복 요청                │    │
│    │                         │  │    → 저장된 결과 반환 (재처리 X)    │    │
│    │                         │  └─────────────────────────────────────┘    │
│    │                         │                                              │
│    │  5. 저장된 결과 반환    │                                              │
│    │◄────────────────────────│                                              │
│    │                         │                                              │
│    │  ┌─────────────────────────────────────────────────────────────┐      │
│    │  │  결과: 10,000원 × 1 = 10,000원만 결제됨 ✓                   │      │
│    │  │  → 이중 결제 방지 성공                                       │      │
│    │  └─────────────────────────────────────────────────────────────┘      │
│                                                                             │
└─────────────────────────────────────────────────────────────────────────────┘
```

---

### Q3-2. 멱등성을 어떻게 구현하나요?

**모범 답안:**

#### 멱등성 구현 방법 비교

```
┌─────────────────────────────────────────────────────────────────────────────┐
│                        멱등성 구현 3가지 방법                                │
├─────────────────────────────────────────────────────────────────────────────┤
│                                                                             │
│  방법 1: 데이터베이스 유니크 제약                                           │
│  ═════════════════════════════════                                          │
│                                                                             │
│     ┌─────────────────────────────────────────────────────────┐            │
│     │                 idempotency_keys 테이블                  │            │
│     ├─────────────────────────────────────────────────────────┤            │
│     │ idempotency_key (PK) │ response (JSON) │ created_at    │            │
│     ├─────────────────────────────────────────────────────────┤            │
│     │ abc123               │ {"status":"OK"} │ 2024-01-15    │            │
│     │ def456               │ {"status":"OK"} │ 2024-01-15    │            │
│     └─────────────────────────────────────────────────────────┘            │
│                                                                             │
│     처리 흐름:                                                              │
│     ┌───────────────────┐                                                  │
│     │ INSERT 시도       │                                                  │
│     └─────────┬─────────┘                                                  │
│               │                                                             │
│       ┌───────┴───────┐                                                    │
│       ▼               ▼                                                    │
│    성공 (신규)     실패 (중복)                                              │
│       │               │                                                    │
│       ▼               ▼                                                    │
│    비즈니스 처리   저장된 결과 반환                                         │
│                                                                             │
│  ─────────────────────────────────────────────────────────────────────────  │
│                                                                             │
│  방법 2: Redis 캐싱                                                         │
│  ══════════════════                                                         │
│                                                                             │
│     Redis:                                                                  │
│     ┌─────────────────────────────────────────────────────────┐            │
│     │ KEY                        │ VALUE           │ TTL     │            │
│     ├─────────────────────────────────────────────────────────┤            │
│     │ idempotency:abc123         │ {"status":"OK"} │ 86400s  │            │
│     │ idempotency:def456         │ {"status":"OK"} │ 86400s  │            │
│     └─────────────────────────────────────────────────────────┘            │
│                                                                             │
│     장점: DB보다 빠름, TTL 자동 만료                                        │
│     단점: 휘발성 (Redis 재시작 시 유실 가능)                                │
│                                                                             │
│  ─────────────────────────────────────────────────────────────────────────  │
│                                                                             │
│  방법 3: INSERT IGNORE (MySQL)                                              │
│  ═════════════════════════════                                              │
│                                                                             │
│     INSERT IGNORE INTO payments (idempotency_key, amount, status)           │
│     VALUES ('abc123', 10000, 'COMPLETED');                                  │
│                                                                             │
│     결과:                                                                   │
│     - affected_rows = 1 → 신규 요청, 처리됨                                 │
│     - affected_rows = 0 → 중복 요청, 무시됨                                 │
│                                                                             │
│     장점: 단일 쿼리로 처리 (원자적)                                         │
│     단점: MySQL 전용                                                        │
│                                                                             │
└─────────────────────────────────────────────────────────────────────────────┘
```

#### 구현 코드 예시

```java
// Redis 기반 멱등성 구현
@Service
@RequiredArgsConstructor
public class IdempotencyService {

    private final RedisTemplate<String, String> redisTemplate;
    private final ObjectMapper objectMapper;

    public <T> Optional<T> getIfExists(String key, Class<T> type) {
        String cached = redisTemplate.opsForValue().get("idempotency:" + key);
        if (cached != null) {
            return Optional.of(objectMapper.readValue(cached, type));
        }
        return Optional.empty();
    }

    public <T> void save(String key, T result, Duration ttl) {
        String value = objectMapper.writeValueAsString(result);
        redisTemplate.opsForValue().set("idempotency:" + key, value, ttl);
    }
}

// 사용 예시
@PostMapping("/payments")
public PaymentResponse processPayment(
        @RequestHeader("X-Idempotency-Key") String idempotencyKey,
        @RequestBody PaymentRequest request) {

    // 1. 기존 결과 확인
    return idempotencyService.getIfExists(idempotencyKey, PaymentResponse.class)
        .orElseGet(() -> {
            // 2. 신규 요청 처리
            PaymentResponse response = paymentService.process(request);

            // 3. 결과 저장
            idempotencyService.save(idempotencyKey, response, Duration.ofHours(24));

            return response;
        });
}
```

---

### Q3-3. HTTP 메서드별 멱등성은 어떻게 되나요?

**모범 답안:**

#### HTTP 메서드 특성 다이어그램

```
┌─────────────────────────────────────────────────────────────────────────────┐
│                       HTTP 메서드별 멱등성과 안전성                          │
├─────────────────────────────────────────────────────────────────────────────┤
│                                                                             │
│                        안전함 (Safe)                                        │
│                    서버 상태 변경 없음                                       │
│                            │                                                │
│                            ▼                                                │
│            ┌───────────────────────────────┐                               │
│            │         GET, HEAD             │                               │
│            │       OPTIONS, TRACE          │                               │
│            │                               │                               │
│            │  여러 번 호출해도 결과 동일   │                               │
│            │  서버 상태 변경 없음          │                               │
│            └───────────────────────────────┘                               │
│                            │                                                │
│                    멱등함 (Idempotent)                                      │
│                            │                                                │
│                            ▼                                                │
│            ┌───────────────────────────────┐                               │
│            │       PUT, DELETE             │                               │
│            │                               │                               │
│            │  여러 번 호출해도 결과 동일   │                               │
│            │  서버 상태는 변경됨           │                               │
│            └───────────────────────────────┘                               │
│                            │                                                │
│                            │                                                │
│                            ▼                                                │
│            ┌───────────────────────────────┐                               │
│            │       POST, PATCH             │                               │
│            │                               │                               │
│            │  호출할 때마다 다른 결과      │                               │
│            │  멱등성 보장 안됨             │                               │
│            │                               │                               │
│            │  → Idempotency-Key 필요!      │                               │
│            └───────────────────────────────┘                               │
│                                                                             │
└─────────────────────────────────────────────────────────────────────────────┘
```

#### 상세 비교표

| 메서드 | 멱등성 | 안전성 | 설명 | 예시 |
|--------|--------|--------|------|------|
| GET | ✓ | ✓ | 조회만, 상태 변경 없음 | 상품 조회 |
| HEAD | ✓ | ✓ | GET과 동일, 본문 없음 | 리소스 존재 확인 |
| PUT | ✓ | ✗ | 전체 교체, 같은 결과 | 상품 정보 수정 |
| DELETE | ✓ | ✗ | 삭제 후 재삭제해도 결과 동일 | 상품 삭제 |
| POST | ✗ | ✗ | 매번 새 리소스 생성 | 주문 생성 |
| PATCH | ✗ | ✗ | 부분 수정, 결과 다를 수 있음 | 재고 증감 |

#### POST의 멱등성 확보

```http
POST /payments HTTP/1.1
Host: api.example.com
X-Idempotency-Key: 550e8400-e29b-41d4-a716-446655440000
Content-Type: application/json

{
  "amount": 10000,
  "orderId": "order-456"
}
```

---

## 4. 동시성 제어

### Q4-1. 단일 서버와 분산 환경에서 동시성 제어가 어떻게 다른가요?

**모범 답안:**

#### 단일 서버 vs 분산 환경 비교

```
┌─────────────────────────────────────────────────────────────────────────────┐
│                         단일 서버 환경                                       │
├─────────────────────────────────────────────────────────────────────────────┤
│                                                                             │
│                      ┌──────────────────────┐                               │
│                      │      JVM (서버 A)     │                               │
│                      │                      │                               │
│      요청 1 ────────►│  synchronized {      │                               │
│                      │    재고 100 → 99     │  ✓ 정상 동작                  │
│      요청 2 ─ 대기 ─►│  }                   │  synchronized가 순차 처리     │
│                      │                      │                               │
│                      └──────────────────────┘                               │
│                                                                             │
│     결과: 재고 98 (2개 정상 차감) ✓                                         │
│                                                                             │
└─────────────────────────────────────────────────────────────────────────────┘

┌─────────────────────────────────────────────────────────────────────────────┐
│                         분산 환경 (여러 서버)                                │
├─────────────────────────────────────────────────────────────────────────────┤
│                                                                             │
│      ┌──────────────────────┐         ┌──────────────────────┐             │
│      │      JVM (서버 A)     │         │      JVM (서버 B)     │             │
│      │                      │         │                      │             │
│      │  synchronized {      │         │  synchronized {      │             │
│      │    재고 100 조회     │ 동시에! │    재고 100 조회     │             │
│      │    100 → 99 저장     │ ◄─────► │    100 → 99 저장     │             │
│      │  }                   │         │  }                   │             │
│      │                      │         │                      │             │
│      └──────────────────────┘         └──────────────────────┘             │
│                                                                             │
│      ⚠️  synchronized는 같은 JVM 내에서만 동작!                             │
│                                                                             │
│      결과: 재고 99 (2개 팔았는데 1개만 차감) ✗ Lost Update!                 │
│                                                                             │
│  ─────────────────────────────────────────────────────────────────────────  │
│                                                                             │
│                           해결: 분산 락                                     │
│                                                                             │
│      ┌──────────────────────┐         ┌──────────────────────┐             │
│      │      JVM (서버 A)     │         │      JVM (서버 B)     │             │
│      │                      │         │                      │             │
│      │  Redis Lock 획득 ✓   │         │  Redis Lock 대기...  │             │
│      │  재고 100 → 99       │ ┌─────┐ │  Lock 획득 ✓         │             │
│      │  Lock 해제           │ │Redis│ │  재고 99 → 98        │             │
│      │                      │ │Lock │ │  Lock 해제           │             │
│      └──────────────────────┘ └─────┘ └──────────────────────┘             │
│                                                                             │
│      결과: 재고 98 (2개 정상 차감) ✓                                        │
│                                                                             │
└─────────────────────────────────────────────────────────────────────────────┘
```

---

### Q4-2. 분산 락(RLock)과 세마포어(RSemaphore)의 차이는 무엇인가요?

**모범 답안:**

#### RLock vs RSemaphore 비교

```
┌─────────────────────────────────────────────────────────────────────────────┐
│                    분산 락 (RLock) - 상호 배제                               │
├─────────────────────────────────────────────────────────────────────────────┤
│                                                                             │
│                         ┌─────────────┐                                     │
│                         │    RLock    │                                     │
│                         │  (1개만!)   │                                     │
│                         └──────┬──────┘                                     │
│                                │                                            │
│     요청 1 ────────────────────┼─────► 처리 중 (락 보유)                   │
│     요청 2 ─────── 대기 ───────┤                                            │
│     요청 3 ─────── 대기 ───────┤                                            │
│     요청 4 ─────── 대기 ───────┘                                            │
│                                                                             │
│     특징:                                                                   │
│     - 동시 접근: 1개만                                                      │
│     - 소유자: 있음 (획득한 스레드만 해제 가능)                              │
│     - 재진입: 가능 (같은 스레드가 여러 번 획득)                             │
│     - 용도: 재고 차감, 좌석 예약 등 순차 처리 필수                          │
│                                                                             │
└─────────────────────────────────────────────────────────────────────────────┘

┌─────────────────────────────────────────────────────────────────────────────┐
│                  세마포어 (RSemaphore) - 동시 접근 제한                       │
├─────────────────────────────────────────────────────────────────────────────┤
│                                                                             │
│                      ┌─────────────────┐                                    │
│                      │   RSemaphore    │                                    │
│                      │  permits = 3    │                                    │
│                      └────────┬────────┘                                    │
│                               │                                             │
│     요청 1 ───────────────────┼─────► 처리 중 (permit 1 사용)              │
│     요청 2 ───────────────────┼─────► 처리 중 (permit 2 사용)              │
│     요청 3 ───────────────────┼─────► 처리 중 (permit 3 사용)              │
│     요청 4 ─────── 대기 ──────┘                                             │
│     요청 5 ─────── 대기 ──────                                              │
│                                                                             │
│     특징:                                                                   │
│     - 동시 접근: N개까지 허용 (permits 설정)                                │
│     - 소유자: 없음 (누구나 release 가능)                                    │
│     - 재진입: 불가                                                          │
│     - 용도: API Rate Limiting, 외부 서비스 동시 호출 제한                   │
│                                                                             │
└─────────────────────────────────────────────────────────────────────────────┘
```

#### 상세 비교표

| 구분 | 분산 락 (RLock) | 세마포어 (RSemaphore) |
|------|-----------------|----------------------|
| 동시 접근 | **1개만** | **N개까지 허용** |
| 용도 | 상호 배제 | 동시 접근 수 제한 |
| 소유자 | 있음 | 없음 |
| 재진입 | 가능 | 불가 |
| Watchdog | 지원 | 미지원 |
| 예시 | 재고 차감 | API Rate Limiting |

#### 사용 예시 코드

```java
// 분산 락: 재고 차감 (순차 처리 필수)
RLock lock = redisson.getLock("lock:stock:" + productId);
try {
    if (lock.tryLock(10, 30, TimeUnit.SECONDS)) {
        // 한 번에 하나의 요청만 처리
        inventoryService.decreaseStock(productId, quantity);
    }
} finally {
    if (lock.isHeldByCurrentThread()) {
        lock.unlock();
    }
}

// 세마포어: PG API 동시 호출 제한 (최대 10개)
RSemaphore semaphore = redisson.getSemaphore("semaphore:pg:toss");
semaphore.trySetPermits(10);  // 최초 한 번 설정
try {
    if (semaphore.tryAcquire(5, TimeUnit.SECONDS)) {
        // 최대 10개 요청까지 동시 처리
        paymentGateway.process(payment);
    }
} finally {
    semaphore.release();
}
```

---

### Q4-3. 낙관적 락과 비관적 락의 차이는 무엇인가요?

**모범 답안:**

#### 낙관적 락 vs 비관적 락 동작 방식

```
┌─────────────────────────────────────────────────────────────────────────────┐
│                         낙관적 락 (Optimistic Lock)                          │
├─────────────────────────────────────────────────────────────────────────────┤
│                                                                             │
│  "충돌이 드물다" 가정 → 락 없이 진행, 커밋 시 검증                          │
│                                                                             │
│  시간 ──────────────────────────────────────────────────────────────────►   │
│                                                                             │
│  트랜잭션 A:                                                                │
│     │ SELECT ... (version=1)                                                │
│     │      │                                                                │
│     │      ▼ 비즈니스 로직 수행                                             │
│     │      │                                                                │
│     │      ▼ UPDATE ... WHERE version=1 ───► version=2 ✓                   │
│     │                                                                       │
│  트랜잭션 B:                                                                │
│     │ SELECT ... (version=1)     ← 같은 버전 읽음                           │
│     │      │                                                                │
│     │      ▼ 비즈니스 로직 수행                                             │
│     │      │                                                                │
│     │      ▼ UPDATE ... WHERE version=1                                    │
│     │                          │                                            │
│     │                          ▼                                            │
│     │                   affected_rows = 0  ← 이미 버전 변경됨!              │
│     │                          │                                            │
│     │                          ▼                                            │
│     │                   OptimisticLockException 발생                        │
│     │                          │                                            │
│     │                          ▼                                            │
│     │                   재시도 로직 실행                                    │
│                                                                             │
│  장점: 락 대기 없음, 처리량 높음                                            │
│  단점: 충돌 시 재시도 필요, 충돌 많으면 성능 저하                           │
│                                                                             │
└─────────────────────────────────────────────────────────────────────────────┘

┌─────────────────────────────────────────────────────────────────────────────┐
│                         비관적 락 (Pessimistic Lock)                         │
├─────────────────────────────────────────────────────────────────────────────┤
│                                                                             │
│  "충돌이 자주 발생" 가정 → 조회 시 락 획득                                  │
│                                                                             │
│  시간 ──────────────────────────────────────────────────────────────────►   │
│                                                                             │
│  트랜잭션 A:                                                                │
│     │ SELECT ... FOR UPDATE  ───► 락 획득 ✓                                │
│     │      │                                                                │
│     │      ▼ 비즈니스 로직 수행 (다른 트랜잭션 대기 중)                     │
│     │      │                                                                │
│     │      ▼ UPDATE ...                                                     │
│     │      │                                                                │
│     │      ▼ COMMIT ───► 락 해제                                           │
│     │                                                                       │
│  트랜잭션 B:                                                                │
│     │ SELECT ... FOR UPDATE                                                 │
│     │      │                                                                │
│     │      ▼ 대기... (A가 락 보유 중)                                       │
│     │      │                                                                │
│     │      ▼ 대기... (A가 락 보유 중)                                       │
│     │      │                                                                │
│     │      ▼ 락 획득 ✓ (A 커밋 후)                                         │
│     │      │                                                                │
│     │      ▼ 비즈니스 로직 수행                                             │
│                                                                             │
│  장점: 충돌 없음, 데이터 일관성 확실                                        │
│  단점: 락 대기로 처리량 감소, 데드락 가능성                                 │
│                                                                             │
└─────────────────────────────────────────────────────────────────────────────┘
```

#### 상세 비교표

| 구분 | 낙관적 락 | 비관적 락 |
|------|----------|----------|
| 가정 | 충돌이 드물다 | 충돌이 자주 발생한다 |
| 락 시점 | 커밋 시 검증 | 조회 시 락 획득 |
| 구현 | @Version, CAS | SELECT FOR UPDATE |
| 성능 | 충돌 적을 때 좋음 | 충돌 많을 때 안전 |
| 대기 | 없음 (실패 시 재시도) | 있음 (락 해제까지 대기) |
| 데드락 | 없음 | 가능성 있음 |

#### 구현 코드 예시

```java
// 낙관적 락 (JPA @Version)
@Entity
public class Order {
    @Id
    private Long id;

    @Version
    private Long version;  // 자동 버전 관리

    private String status;
}

// 자동 생성되는 쿼리:
// UPDATE orders SET status=?, version=version+1
// WHERE id=? AND version=?

// 비관적 락 (SELECT FOR UPDATE)
public interface OrderRepository extends JpaRepository<Order, Long> {

    @Lock(LockModeType.PESSIMISTIC_WRITE)
    @Query("SELECT o FROM Order o WHERE o.id = :id")
    Optional<Order> findByIdForUpdate(@Param("id") Long id);
}
```

---

### Q4-4. 서비스별로 다른 동시성 제어 전략을 사용하는 이유는 무엇인가요?

**모범 답안:**

#### 서비스별 동시성 제어 전략

```
┌─────────────────────────────────────────────────────────────────────────────┐
│                      서비스별 동시성 제어 전략 선택                          │
├─────────────────────────────────────────────────────────────────────────────┤
│                                                                             │
│  ┌─────────────────────────────────────────────────────────────────────┐   │
│  │  Order Service → 낙관적 락 (@Version)                                │   │
│  ├─────────────────────────────────────────────────────────────────────┤   │
│  │                                                                      │   │
│  │  주문 상태: CREATED → PAID → SHIPPED → DELIVERED                    │   │
│  │                                                                      │   │
│  │  특징:                                                               │   │
│  │  - 같은 주문을 동시에 수정하는 경우 드묾                            │   │
│  │  - 충돌 시 재시도로 해결 가능                                        │   │
│  │  - 높은 처리량 필요                                                  │   │
│  │                                                                      │   │
│  │  @Version                                                            │   │
│  │  private Long version;                                               │   │
│  │                                                                      │   │
│  └─────────────────────────────────────────────────────────────────────┘   │
│                                                                             │
│  ┌─────────────────────────────────────────────────────────────────────┐   │
│  │  Inventory Service → 분산 락 (RLock)                                 │   │
│  ├─────────────────────────────────────────────────────────────────────┤   │
│  │                                                                      │   │
│  │  인기 상품:                                                          │   │
│  │  ┌─────────────────────────────────────────────────────────┐        │   │
│  │  │  동시 100명 → 재고 1개 상품 주문                         │        │   │
│  │  │  → 반드시 순차 처리해야 overselling 방지                │        │   │
│  │  └─────────────────────────────────────────────────────────┘        │   │
│  │                                                                      │   │
│  │  RLock lock = redisson.getLock("lock:stock:" + productId);          │   │
│  │  lock.tryLock(10, 30, TimeUnit.SECONDS);                            │   │
│  │                                                                      │   │
│  └─────────────────────────────────────────────────────────────────────┘   │
│                                                                             │
│  ┌─────────────────────────────────────────────────────────────────────┐   │
│  │  Payment Service → 세마포어 (RSemaphore)                             │   │
│  ├─────────────────────────────────────────────────────────────────────┤   │
│  │                                                                      │   │
│  │  PG사 API 제한: TPS 10                                               │   │
│  │  ┌─────────────────────────────────────────────────────────┐        │   │
│  │  │  동시 요청 100개 → 10개씩 순차 처리                      │        │   │
│  │  │  → PG사 Rate Limit 준수                                 │        │   │
│  │  └─────────────────────────────────────────────────────────┘        │   │
│  │                                                                      │   │
│  │  RSemaphore semaphore = redisson.getSemaphore("semaphore:pg:toss"); │   │
│  │  semaphore.trySetPermits(10);  // 동시 10개                          │   │
│  │                                                                      │   │
│  └─────────────────────────────────────────────────────────────────────┘   │
│                                                                             │
│  ┌─────────────────────────────────────────────────────────────────────┐   │
│  │  Notification Service → 세마포어 (RSemaphore) + 채널별 제한          │   │
│  ├─────────────────────────────────────────────────────────────────────┤   │
│  │                                                                      │   │
│  │  채널별 동시 발송 제한:                                              │   │
│  │  ┌────────────────────────────────────────────────────────┐         │   │
│  │  │  SMS: 5개 (비용 높음, 제한적 사용)                      │         │   │
│  │  │  Email: 20개 (비용 낮음, 대량 발송)                     │         │   │
│  │  │  Push: 50개 (무료, 대량 발송)                           │         │   │
│  │  └────────────────────────────────────────────────────────┘         │   │
│  │                                                                      │   │
│  │  RSemaphore smsSemaphore = redisson.getSemaphore("semaphore:sms");  │   │
│  │  RSemaphore emailSemaphore = redisson.getSemaphore("semaphore:email");│  │
│  │                                                                      │   │
│  └─────────────────────────────────────────────────────────────────────┘   │
│                                                                             │
└─────────────────────────────────────────────────────────────────────────────┘
```

---

### Q4-5. 분산 락 사용 시 주의할 점은 무엇인가요?

**모범 답안:**

#### 분산 락 주의사항

```
┌─────────────────────────────────────────────────────────────────────────────┐
│                         분산 락 5대 주의사항                                 │
├─────────────────────────────────────────────────────────────────────────────┤
│                                                                             │
│  1. leaseTime 설정 필수                                                     │
│  ══════════════════════                                                     │
│                                                                             │
│     ✗ 나쁜 예: 서버 다운 시 영구 락                                         │
│     ─────────────────────────────────                                       │
│     lock.lock();  // leaseTime 없음                                         │
│     // 서버 다운 → 락 영원히 해제 안됨 → 데드락!                            │
│                                                                             │
│     ✓ 좋은 예: 자동 해제                                                    │
│     ─────────────────────────────                                           │
│     lock.tryLock(10, 30, TimeUnit.SECONDS);                                 │
│     // waitTime: 10초 대기                                                  │
│     // leaseTime: 30초 후 자동 해제                                         │
│                                                                             │
│  ─────────────────────────────────────────────────────────────────────────  │
│                                                                             │
│  2. finally에서 unlock (안전한 해제)                                        │
│  ═══════════════════════════════════                                        │
│                                                                             │
│     try {                                                                   │
│         if (lock.tryLock(10, 30, TimeUnit.SECONDS)) {                       │
│             // 비즈니스 로직                                                │
│         }                                                                   │
│     } finally {                                                             │
│         if (lock.isHeldByCurrentThread()) {  // 중요!                       │
│             lock.unlock();                                                  │
│         }                                                                   │
│     }                                                                       │
│                                                                             │
│     // isHeldByCurrentThread() 체크 이유:                                   │
│     // - tryLock 실패 시 unlock 호출하면 예외 발생                          │
│     // - 다른 스레드의 락을 해제하면 안됨                                   │
│                                                                             │
│  ─────────────────────────────────────────────────────────────────────────  │
│                                                                             │
│  3. 락 범위 최소화                                                          │
│  ═══════════════════                                                        │
│                                                                             │
│     ✗ 나쁜 예: 불필요하게 넓은 락 범위                                      │
│     ─────────────────────────────────────                                   │
│     lock.lock();                                                            │
│     validateRequest();     // 락 불필요 (읽기만)                            │
│     fetchExternalData();   // 락 불필요 (외부 호출, 시간 오래 걸림)         │
│     updateStock();         // 락 필요                                       │
│     sendNotification();    // 락 불필요 (비동기 처리 가능)                  │
│     lock.unlock();                                                          │
│                                                                             │
│     ✓ 좋은 예: 필요한 부분만 락                                             │
│     ────────────────────────────────                                        │
│     validateRequest();                                                      │
│     fetchExternalData();                                                    │
│     lock.lock();           // 락 시작                                       │
│     updateStock();         // 락 필요한 부분만                              │
│     lock.unlock();         // 락 종료                                       │
│     sendNotification();                                                     │
│                                                                             │
│  ─────────────────────────────────────────────────────────────────────────  │
│                                                                             │
│  4. Watchdog 활용 (작업 시간 예측 불가 시)                                  │
│  ═══════════════════════════════════════                                    │
│                                                                             │
│     문제 상황:                                                              │
│     ┌─────────────────────────────────────────────────────────────┐        │
│     │ 서버 A: 락 획득 (TTL 30초)                                   │        │
│     │ 작업이 예상보다 오래 걸림 (40초)                             │        │
│     │ 30초 후 락 만료 → 서버 B가 락 획득                           │        │
│     │ 서버 A, B 둘 다 작업 중 → 데이터 불일치!                     │        │
│     └─────────────────────────────────────────────────────────────┘        │
│                                                                             │
│     해결: Watchdog                                                          │
│     ┌─────────────────────────────────────────────────────────────┐        │
│     │ lock.tryLock(waitTime, -1, TimeUnit.SECONDS);               │        │
│     │ // leaseTime = -1 → Watchdog 활성화                         │        │
│     │ // 30초(기본값)마다 자동으로 TTL 갱신                        │        │
│     │ // 작업 완료까지 락 유지                                     │        │
│     └─────────────────────────────────────────────────────────────┘        │
│                                                                             │
│  ─────────────────────────────────────────────────────────────────────────  │
│                                                                             │
│  5. 락 키 설계                                                              │
│  ═════════════                                                              │
│                                                                             │
│     ✗ 나쁜 예: 너무 넓은 범위                                               │
│     ────────────────────────────                                            │
│     redisson.getLock("lock:inventory");  // 전체 재고에 락                  │
│     → 상품 A 재고 수정 시 상품 B, C, D도 대기                               │
│                                                                             │
│     ✓ 좋은 예: 세분화된 락 키                                               │
│     ────────────────────────────────                                        │
│     redisson.getLock("lock:stock:" + productId);  // 상품별 락              │
│     → 상품 A 재고 수정 시 상품 B, C, D는 독립 처리                          │
│                                                                             │
└─────────────────────────────────────────────────────────────────────────────┘
```

---

## 5. Resilience4j - 장애 대응

### Q5-1. Circuit Breaker가 무엇이고, 어떻게 동작하나요?

**모범 답안:**

**정의:** 연속적인 실패가 감지되면 호출을 차단하여 연쇄 장애를 방지하는 패턴

#### Circuit Breaker 상태 전이 다이어그램

```
┌─────────────────────────────────────────────────────────────────────────────┐
│                    Circuit Breaker 상태 전이 다이어그램                       │
├─────────────────────────────────────────────────────────────────────────────┤
│                                                                             │
│                        ┌──────────────────────┐                             │
│                        │       CLOSED         │                             │
│                        │       (정상)         │                             │
│                        │                      │                             │
│      ┌───────────────► │  모든 요청 허용      │ ◄──────────────┐            │
│      │                 │  실패율 모니터링     │                │            │
│      │                 └──────────┬───────────┘                │            │
│      │                            │                            │            │
│      │                            │ 실패율 ≥ 50%               │            │
│      │                            │ (최근 10개 중 5개 실패)     │            │
│      │                            │                            │            │
│      │                            ▼                            │            │
│      │                 ┌──────────────────────┐                │            │
│      │                 │        OPEN          │                │            │
│      │                 │       (차단)         │                │            │
│      │                 │                      │                │            │
│      │                 │  모든 요청 즉시 실패 │                │            │
│      │                 │  fallback 메서드 호출│                │            │
│      │                 │                      │                │            │
│      │                 │  ⏱️ 대기 (30초)       │                │            │
│      │                 └──────────┬───────────┘                │            │
│      │                            │                            │            │
│      │                            │ 30초 경과                  │            │
│      │                            │                            │            │
│      │                            ▼                            │            │
│      │                 ┌──────────────────────┐                │            │
│      │                 │      HALF_OPEN       │                │            │
│      │  성공률 충분    │      (테스트)        │  실패율 높음   │            │
│      │  (≥ 50%)       │                      │  (≥ 50%)       │            │
│      │                 │  제한된 요청 허용    │                │            │
│      │                 │  (5개만 테스트)      │ ───────────────┘            │
│      └───────────────  │                      │                             │
│                        └──────────────────────┘                             │
│                                                                             │
│  ═══════════════════════════════════════════════════════════════════════   │
│                                                                             │
│  핵심 개념:                                                                 │
│  - Sliding Window: 최근 N개 요청의 실패율 계산                             │
│  - Failure Rate Threshold: OPEN 전환 기준 (기본 50%)                       │
│  - Wait Duration: OPEN 상태 유지 시간 (기본 60초)                          │
│  - Permitted Calls in Half-Open: 테스트 호출 수 (기본 10개)                │
│                                                                             │
└─────────────────────────────────────────────────────────────────────────────┘
```

#### 연쇄 장애 방지 시나리오

```
┌─────────────────────────────────────────────────────────────────────────────┐
│                     Circuit Breaker가 없을 때 (연쇄 장애)                    │
├─────────────────────────────────────────────────────────────────────────────┤
│                                                                             │
│   Client        Order Service      Inventory Service     Database          │
│     │                │                    │                  │              │
│     │  주문 요청     │                    │                  │              │
│     │───────────────►│                    │                  │              │
│     │                │  재고 확인 요청    │                  │              │
│     │                │───────────────────►│                  │              │
│     │                │                    │  쿼리            │              │
│     │                │                    │─────────────────►│              │
│     │                │                    │                  │ DB 다운!     │
│     │                │                    │◄─ 타임아웃 (30초)│              │
│     │                │◄─ 타임아웃 (30초) ─│                  │              │
│     │◄─ 타임아웃 (30초)                   │                  │              │
│     │                │                    │                  │              │
│     │  ┌─────────────────────────────────────────────────────────────┐     │
│     │  │  문제:                                                       │     │
│     │  │  - 30초 × N명 = 스레드 풀 고갈                               │     │
│     │  │  - Order Service도 응답 불능                                 │     │
│     │  │  - 연쇄 장애 발생!                                           │     │
│     │  └─────────────────────────────────────────────────────────────┘     │
│                                                                             │
└─────────────────────────────────────────────────────────────────────────────┘

┌─────────────────────────────────────────────────────────────────────────────┐
│                     Circuit Breaker가 있을 때 (장애 격리)                    │
├─────────────────────────────────────────────────────────────────────────────┤
│                                                                             │
│   Client        Order Service      Inventory Service                        │
│     │                │                    │                                 │
│     │  주문 요청 1-5 │                    │                                 │
│     │───────────────►│───────────────────►│ ← 5번 실패 (50% 실패율)        │
│     │◄───────────────│◄───────────────────│                                 │
│     │                │                    │                                 │
│     │                │  ┌─────────────────────────────────────┐            │
│     │                │  │ Circuit Breaker: OPEN 전환!         │            │
│     │                │  └─────────────────────────────────────┘            │
│     │                │                    │                                 │
│     │  주문 요청 6   │                    │                                 │
│     │───────────────►│  ✗ 즉시 차단      │                                 │
│     │◄───────────────│  (Inventory 호출 X)                                 │
│     │  fallback 응답 │                    │                                 │
│     │  (1ms 이내)    │                    │                                 │
│     │                │                    │                                 │
│     │  ┌─────────────────────────────────────────────────────────────┐     │
│     │  │  장점:                                                       │     │
│     │  │  - 즉시 fallback 응답 (30초 대기 없음)                       │     │
│     │  │  - Order Service 스레드 풀 보호                              │     │
│     │  │  - Inventory 복구 시간 확보                                  │     │
│     │  └─────────────────────────────────────────────────────────────┘     │
│                                                                             │
└─────────────────────────────────────────────────────────────────────────────┘
```

#### 설정 예시

```yaml
resilience4j:
  circuitbreaker:
    instances:
      inventoryService:
        failure-rate-threshold: 50       # 실패율 50% → OPEN
        wait-duration-in-open-state: 30s # OPEN 유지 시간
        permitted-calls-in-half-open: 5  # HALF_OPEN에서 테스트 호출 수
        sliding-window-size: 10          # 최근 10개 요청 기준
        sliding-window-type: COUNT_BASED # 개수 기반 (또는 TIME_BASED)
```

---

### Q5-2. Retry와 Circuit Breaker를 함께 사용할 때 순서는 어떻게 되나요?

**모범 답안:**

#### 올바른 순서 다이어그램

```
┌─────────────────────────────────────────────────────────────────────────────┐
│                    올바른 순서: Retry → CircuitBreaker                       │
├─────────────────────────────────────────────────────────────────────────────┤
│                                                                             │
│   요청 ─────► Retry ─────► CircuitBreaker ─────► 실제 호출                 │
│                │                  │                   │                     │
│                │                  │                   │                     │
│                ▼                  ▼                   ▼                     │
│           ┌─────────┐       ┌───────────┐      ┌───────────┐               │
│           │ 3번     │       │  1번의    │      │  외부     │               │
│           │ 재시도  │ ───►  │  성공/실패│ ───► │  서비스   │               │
│           │         │       │  로 기록  │      │           │               │
│           └─────────┘       └───────────┘      └───────────┘               │
│                                                                             │
│   예시:                                                                     │
│   ┌─────────────────────────────────────────────────────────────────────┐  │
│   │ 1회차 호출: 실패 (Retry가 재시도 결정)                              │  │
│   │ 2회차 재시도: 실패 (Retry가 재시도 결정)                            │  │
│   │ 3회차 재시도: 실패 (Retry 최대 횟수 도달)                           │  │
│   │                                                                      │  │
│   │ → CircuitBreaker에 "1번 실패"로 기록                                │  │
│   │ → 아직 CLOSED 상태 유지 (실패율 10%)                                │  │
│   └─────────────────────────────────────────────────────────────────────┘  │
│                                                                             │
└─────────────────────────────────────────────────────────────────────────────┘

┌─────────────────────────────────────────────────────────────────────────────┐
│                    잘못된 순서: CircuitBreaker → Retry                       │
├─────────────────────────────────────────────────────────────────────────────┤
│                                                                             │
│   요청 ─────► CircuitBreaker ─────► Retry ─────► 실제 호출                 │
│                     │                  │                                    │
│                     │                  │                                    │
│                     ▼                  ▼                                    │
│               ┌───────────┐       ┌─────────┐                              │
│               │  3번의    │       │ 3번     │                              │
│               │  실패로   │ ◄───  │ 재시도  │                              │
│               │  기록!    │       │         │                              │
│               └───────────┘       └─────────┘                              │
│                                                                             │
│   예시:                                                                     │
│   ┌─────────────────────────────────────────────────────────────────────┐  │
│   │ 1회차 호출: 실패 → CircuitBreaker에 "1번 실패" 기록                 │  │
│   │ 2회차 재시도: 실패 → CircuitBreaker에 "2번 실패" 기록               │  │
│   │ 3회차 재시도: 실패 → CircuitBreaker에 "3번 실패" 기록               │  │
│   │                                                                      │  │
│   │ → 단 1번의 요청으로 3번 실패 기록됨!                                │  │
│   │ → 빠르게 OPEN 상태 전환 (잘못된 동작)                               │  │
│   └─────────────────────────────────────────────────────────────────────┘  │
│                                                                             │
└─────────────────────────────────────────────────────────────────────────────┘
```

#### 올바른 어노테이션 순서

```java
// 어노테이션 순서 = 안쪽에서 바깥쪽으로 적용
// Retry → CircuitBreaker 순서로 동작

@Retry(name = "inventoryService")        // 2. 바깥: Retry가 먼저 감싸고
@CircuitBreaker(name = "inventoryService", fallbackMethod = "fallback")  // 1. 안쪽: CB가 호출
public Response callInventory() {
    return inventoryClient.getStock(productId);
}

// 동작 순서:
// 요청 → @Retry → @CircuitBreaker → inventoryClient.getStock()
```

---

### Q5-3. Resilience4j의 4가지 핵심 모듈을 설명해주세요.

**모범 답안:**

#### 4가지 모듈 개요

```
┌─────────────────────────────────────────────────────────────────────────────┐
│                       Resilience4j 4대 모듈                                  │
├─────────────────────────────────────────────────────────────────────────────┤
│                                                                             │
│  ┌─────────────────────────────────────────────────────────────────────┐   │
│  │  1. Retry (재시도)                                                   │   │
│  ├─────────────────────────────────────────────────────────────────────┤   │
│  │                                                                      │   │
│  │  요청 ───► 실패 ───► 1초 대기 ───► 재시도 ───► 성공 ✓              │   │
│  │                                                                      │   │
│  │  용도: 일시적 장애 (네트워크 순단, 일시적 타임아웃)                 │   │
│  │  설정: 최대 재시도 횟수, 대기 시간, 지수 백오프                     │   │
│  │                                                                      │   │
│  └─────────────────────────────────────────────────────────────────────┘   │
│                                                                             │
│  ┌─────────────────────────────────────────────────────────────────────┐   │
│  │  2. Circuit Breaker (서킷 브레이커)                                  │   │
│  ├─────────────────────────────────────────────────────────────────────┤   │
│  │                                                                      │   │
│  │  CLOSED ──(실패 누적)──► OPEN ──(대기)──► HALF_OPEN ──► CLOSED     │   │
│  │                           │                                          │   │
│  │                           └──► 즉시 실패 (fallback)                  │   │
│  │                                                                      │   │
│  │  용도: 장기 장애 (서비스 다운, DB 장애)                             │   │
│  │  설정: 실패율 임계값, 대기 시간, 슬라이딩 윈도우 크기               │   │
│  │                                                                      │   │
│  └─────────────────────────────────────────────────────────────────────┘   │
│                                                                             │
│  ┌─────────────────────────────────────────────────────────────────────┐   │
│  │  3. TimeLimiter (타임아웃)                                           │   │
│  ├─────────────────────────────────────────────────────────────────────┤   │
│  │                                                                      │   │
│  │  요청 ───► 3초 내 응답? ───► Yes: 정상 응답                         │   │
│  │                         └──► No: TimeoutException                   │   │
│  │                                                                      │   │
│  │  용도: 느린 응답 방지 (무한 대기 방지)                              │   │
│  │  설정: 타임아웃 시간 (기본 1초)                                     │   │
│  │                                                                      │   │
│  └─────────────────────────────────────────────────────────────────────┘   │
│                                                                             │
│  ┌─────────────────────────────────────────────────────────────────────┐   │
│  │  4. RateLimiter (호출 제한)                                          │   │
│  ├─────────────────────────────────────────────────────────────────────┤   │
│  │                                                                      │   │
│  │  [1초당 10회 제한]                                                   │   │
│  │  요청 1-10: 통과 ✓                                                   │   │
│  │  요청 11: 대기 또는 거부 ✗                                          │   │
│  │                                                                      │   │
│  │  용도: API 과부하 방지, 외부 서비스 Rate Limit 준수                 │   │
│  │  설정: 제한 횟수, 갱신 주기                                         │   │
│  │                                                                      │   │
│  └─────────────────────────────────────────────────────────────────────┘   │
│                                                                             │
└─────────────────────────────────────────────────────────────────────────────┘
```

#### 모듈 비교표

| 모듈 | 용도 | 예시 상황 | 동작 |
|------|------|----------|------|
| **Retry** | 일시적 실패 시 재시도 | 네트워크 순간 끊김 | N번 재시도 후 포기 |
| **CircuitBreaker** | 연속 실패 시 차단 | 서비스 다운 | 빠른 실패로 리소스 보호 |
| **TimeLimiter** | 타임아웃 설정 | 응답 지연 | 지정 시간 초과 시 실패 |
| **RateLimiter** | 호출 횟수 제한 | API 과부하 방지 | 초과 요청 대기/거부 |

#### 조합 사용 (권장 순서)

```java
// 권장 적용 순서: Retry → CircuitBreaker → RateLimiter → TimeLimiter
// (안쪽에서 바깥쪽으로)

@Retry(name = "external")
@CircuitBreaker(name = "external", fallbackMethod = "fallback")
@RateLimiter(name = "external")
@TimeLimiter(name = "external")
public CompletableFuture<Response> callExternalApi() {
    return CompletableFuture.supplyAsync(() -> externalClient.call());
}

// 설정 예시
resilience4j:
  retry:
    instances:
      external:
        max-attempts: 3
        wait-duration: 1s

  circuitbreaker:
    instances:
      external:
        failure-rate-threshold: 50
        wait-duration-in-open-state: 30s

  ratelimiter:
    instances:
      external:
        limit-for-period: 10
        limit-refresh-period: 1s

  timelimiter:
    instances:
      external:
        timeout-duration: 3s
```

---

### Q5-4. Resilience4j는 어느 서비스에 적용해야 하나요?

**모범 답안:**

#### 적용 위치 다이어그램

```
┌─────────────────────────────────────────────────────────────────────────────┐
│                     Resilience4j 적용 위치: 호출하는 쪽!                     │
├─────────────────────────────────────────────────────────────────────────────┤
│                                                                             │
│                                                                             │
│   ┌────────────────────────────────────────────────────────────────────┐   │
│   │                       Order Service                                 │   │
│   │                                                                     │   │
│   │   @CircuitBreaker(name = "inventory")     ← Resilience4j 적용      │   │
│   │   @Retry(name = "inventory")                                        │   │
│   │   public StockResponse reserveStock(Long productId, int qty) {      │   │
│   │       return inventoryClient.reserve(productId, qty);               │   │
│   │   }                                                                 │   │
│   │                                                                     │   │
│   │   public StockResponse fallback(Long productId, int qty, Throwable t) {│
│   │       log.warn("Inventory unavailable");                            │   │
│   │       return StockResponse.pending();  // 대기 상태로 반환         │   │
│   │   }                                                                 │   │
│   │                                                                     │   │
│   └────────────────────────────┬───────────────────────────────────────┘   │
│                                │                                            │
│                                │ REST 호출                                  │
│                                │                                            │
│                                ▼                                            │
│   ┌────────────────────────────────────────────────────────────────────┐   │
│   │                     Inventory Service                               │   │
│   │                                                                     │   │
│   │   // Resilience4j 적용 안함!                                       │   │
│   │   // 자신의 장애는 자신이 처리할 수 없음                           │   │
│   │                                                                     │   │
│   │   @GetMapping("/stock/{productId}")                                │   │
│   │   public StockResponse getStock(@PathVariable Long productId) {     │   │
│   │       return stockService.getStock(productId);                      │   │
│   │   }                                                                 │   │
│   │                                                                     │   │
│   └────────────────────────────────────────────────────────────────────┘   │
│                                                                             │
│  ═══════════════════════════════════════════════════════════════════════   │
│                                                                             │
│  핵심 원칙:                                                                 │
│  ┌─────────────────────────────────────────────────────────────────────┐   │
│  │  "호출하는 쪽"이 "호출받는 쪽"의 장애에 대비해야 한다               │   │
│  │                                                                      │   │
│  │  - Order Service가 Inventory 장애에 대응 (Circuit Breaker)          │   │
│  │  - Order Service가 일시적 실패에 대응 (Retry)                       │   │
│  │  - Order Service가 느린 응답에 대응 (TimeLimiter)                   │   │
│  │                                                                      │   │
│  │  → Inventory가 다운되어도 Order는 fallback으로 정상 응답 가능       │   │
│  └─────────────────────────────────────────────────────────────────────┘   │
│                                                                             │
└─────────────────────────────────────────────────────────────────────────────┘
```

#### 전체 시스템 적용 예시

```
┌─────────────────────────────────────────────────────────────────────────────┐
│                     서비스별 Resilience4j 적용 현황                          │
├─────────────────────────────────────────────────────────────────────────────┤
│                                                                             │
│                        ┌─────────────────┐                                  │
│                        │   Orchestrator  │                                  │
│                        │                 │                                  │
│                        │  CB: order      │ ← 각 서비스 호출에 적용         │
│                        │  CB: inventory  │                                  │
│                        │  CB: payment    │                                  │
│                        └────────┬────────┘                                  │
│                                 │                                           │
│              ┌──────────────────┼──────────────────┐                        │
│              │                  │                  │                        │
│              ▼                  ▼                  ▼                        │
│   ┌─────────────────┐ ┌─────────────────┐ ┌─────────────────┐              │
│   │  Order Service  │ │Inventory Service│ │ Payment Service │              │
│   │                 │ │                 │ │                 │              │
│   │  (적용 없음)    │ │  (적용 없음)    │ │  CB: pg-gateway │ ← 외부 PG   │
│   │                 │ │                 │ │  Retry: pg      │              │
│   └─────────────────┘ └─────────────────┘ └────────┬────────┘              │
│                                                     │                       │
│                                                     ▼                       │
│                                          ┌─────────────────┐               │
│                                          │   PG Gateway    │               │
│                                          │   (외부 서비스)  │               │
│                                          └─────────────────┘               │
│                                                                             │
└─────────────────────────────────────────────────────────────────────────────┘
```

---

## 6. Redis & Redisson

### Q6-1. Redis의 주요 자료구조와 사용 사례를 설명해주세요.

**모범 답안:**

#### Redis 자료구조 개요

```
┌─────────────────────────────────────────────────────────────────────────────┐
│                         Redis 6대 자료구조                                   │
├─────────────────────────────────────────────────────────────────────────────┤
│                                                                             │
│  1. String (문자열)                                                         │
│  ═════════════════                                                          │
│     SET user:1:name "Alice"                                                 │
│     GET user:1:name  →  "Alice"                                             │
│     INCR counter     →  1, 2, 3, ...                                        │
│                                                                             │
│     용도: 세션, 캐싱, 카운터, 분산 락                                       │
│                                                                             │
│  ─────────────────────────────────────────────────────────────────────────  │
│                                                                             │
│  2. Hash (해시)                                                             │
│  ══════════════                                                             │
│     HSET user:1 name "Alice" age 30 email "alice@mail.com"                 │
│     HGET user:1 name  →  "Alice"                                            │
│     HGETALL user:1    →  {name: "Alice", age: 30, email: "..."}            │
│                                                                             │
│     용도: 객체 저장 (사용자 정보, 상품 정보)                                │
│                                                                             │
│  ─────────────────────────────────────────────────────────────────────────  │
│                                                                             │
│  3. List (리스트)                                                           │
│  ═════════════════                                                          │
│     RPUSH queue:orders "order1" "order2"   →  [order1, order2]             │
│     LPOP queue:orders                      →  "order1"                      │
│     LRANGE queue:orders 0 -1               →  ["order2"]                    │
│                                                                             │
│     용도: 메시지 큐, 최근 항목, 타임라인                                    │
│                                                                             │
│  ─────────────────────────────────────────────────────────────────────────  │
│                                                                             │
│  4. Set (집합)                                                              │
│  ══════════════                                                             │
│     SADD product:1:tags "electronics" "sale" "new"                         │
│     SMEMBERS product:1:tags  →  {"electronics", "sale", "new"}             │
│     SINTER tag:sale tag:new  →  교집합 (세일 + 신상품)                      │
│                                                                             │
│     용도: 태그, 유니크 방문자, 친구 목록                                    │
│                                                                             │
│  ─────────────────────────────────────────────────────────────────────────  │
│                                                                             │
│  5. Sorted Set (정렬 집합)                                                  │
│  ══════════════════════════                                                 │
│     ZADD leaderboard 100 "player1" 85 "player2" 92 "player3"               │
│     ZREVRANGE leaderboard 0 2  →  ["player1", "player3", "player2"]        │
│     ZRANK leaderboard "player2"  →  0 (최하위)                              │
│                                                                             │
│     용도: 랭킹, 우선순위 큐, 타임스탬프 기반 정렬                           │
│                                                                             │
│  ─────────────────────────────────────────────────────────────────────────  │
│                                                                             │
│  6. Stream (스트림)                                                         │
│  ══════════════════                                                         │
│     XADD orders * productId 1 quantity 2                                   │
│     XREAD STREAMS orders 0  →  메시지 목록                                  │
│     XACK orders group1 1234567-0  →  처리 완료 확인                         │
│                                                                             │
│     용도: 이벤트 소싱, 메시지 큐, 로그 수집                                 │
│                                                                             │
└─────────────────────────────────────────────────────────────────────────────┘
```

#### 자료구조 선택 가이드

| 자료구조 | 명령어 | 사용 사례 | 시간복잡도 |
|----------|--------|----------|-----------|
| **String** | SET, GET, INCR | 세션, 캐싱, 카운터 | O(1) |
| **Hash** | HSET, HGET, HGETALL | 객체 저장 | O(1) |
| **List** | RPUSH, LPOP, LRANGE | 메시지 큐, 최근 항목 | O(1)/O(N) |
| **Set** | SADD, SMEMBERS, SINTER | 태그, 유니크 방문자 | O(1)/O(N) |
| **Sorted Set** | ZADD, ZRANGE, ZRANK | 랭킹, 우선순위 큐 | O(log N) |
| **Stream** | XADD, XREAD, XACK | 이벤트 소싱, MQ | O(1) |

---

### Q6-2. Redisson은 무엇이고, Lettuce/Jedis와 어떻게 다른가요?

**모범 답안:**

#### 추상화 수준 비교

```
┌─────────────────────────────────────────────────────────────────────────────┐
│                    Jedis/Lettuce vs Redisson 비교                            │
├─────────────────────────────────────────────────────────────────────────────┤
│                                                                             │
│  Jedis/Lettuce (저수준)                    Redisson (고수준)                │
│  ════════════════════════                  ══════════════════               │
│                                                                             │
│  // Redis 명령어 직접 사용                 // Java 객체처럼 사용            │
│                                                                             │
│  // 캐싱                                   // 캐싱                          │
│  redisTemplate                             RMap<String, User> users =       │
│    .opsForValue()                            redisson.getMap("users");      │
│    .set("user:1",                          users.put("1", new User("Alice"));│
│         objectMapper                       User user = users.get("1");      │
│           .writeValueAsString(user));                                       │
│  String json = redisTemplate              // 자동 직렬화/역직렬화           │
│    .opsForValue().get("user:1");                                            │
│  User user = objectMapper                                                   │
│    .readValue(json, User.class);                                            │
│                                                                             │
│  ─────────────────────────────────────────────────────────────────────────  │
│                                                                             │
│  // 분산 락 (직접 구현 필요!)              // 분산 락 (내장)                │
│                                                                             │
│  String lockKey = "lock:stock:" + id;     RLock lock = redisson            │
│  String lockValue = UUID.randomUUID();       .getLock("lock:stock:" + id); │
│  Boolean acquired = redisTemplate         if (lock.tryLock(10, 30, SECONDS))│
│    .opsForValue()                           try {                          │
│    .setIfAbsent(lockKey, lockValue,           // 비즈니스 로직             │
│      Duration.ofSeconds(30));               } finally {                     │
│  // 해제 시 Lua 스크립트 필요...              lock.unlock();               │
│                                             }                               │
│                                                                             │
│  ─────────────────────────────────────────────────────────────────────────  │
│                                                                             │
│  비유:                                                                      │
│  ┌─────────────────────────────────────────────────────────────────────┐   │
│  │  Jedis/Lettuce = JDBC (SQL 직접 작성)                               │   │
│  │  Redisson      = JPA  (객체 매핑 자동화)                            │   │
│  └─────────────────────────────────────────────────────────────────────┘   │
│                                                                             │
└─────────────────────────────────────────────────────────────────────────────┘
```

#### 상세 비교표

| 구분 | Jedis/Lettuce | Redisson |
|------|---------------|----------|
| 추상화 수준 | 저수준 (Redis 명령어) | 고수준 (Java 객체) |
| 분산 락 | 직접 구현 필요 (Lua 스크립트) | **RLock 내장** |
| 분산 컬렉션 | 없음 | RMap, RSet, RList 제공 |
| Watchdog | 없음 | **자동 락 갱신** |
| 세마포어 | 직접 구현 필요 | RSemaphore 내장 |
| 학습 곡선 | 낮음 | 중간 |
| Spring 통합 | spring-data-redis | redisson-spring-boot-starter |

---

### Q6-3. Redisson의 Watchdog은 무엇인가요?

**모범 답안:**

#### Watchdog 동작 원리

```
┌─────────────────────────────────────────────────────────────────────────────┐
│                      Watchdog이 없을 때 발생하는 문제                        │
├─────────────────────────────────────────────────────────────────────────────┤
│                                                                             │
│  시간 ──────────────────────────────────────────────────────────────────►   │
│        0초        10초        20초        30초        40초                  │
│         │          │          │          │          │                       │
│  서버A  │ 락 획득  │ 작업중   │ 작업중   │ 락만료!  │ 작업중..             │
│         │ TTL:30초 │          │          │          │                       │
│         │          │          │          │ ┌────────┴───────┐               │
│         │          │          │          │ │ 서버 B가       │               │
│         │          │          │          │ │ 락 획득!       │               │
│         │          │          │          │ └────────────────┘               │
│  서버B  │          │          │          │ 락 획득  │ 작업중               │
│         │          │          │          │          │                       │
│                                                                             │
│  ⚠️ 30초 이후: 서버 A, B 둘 다 작업 중 → 데이터 불일치!                    │
│                                                                             │
└─────────────────────────────────────────────────────────────────────────────┘

┌─────────────────────────────────────────────────────────────────────────────┐
│                      Watchdog이 있을 때 (자동 갱신)                          │
├─────────────────────────────────────────────────────────────────────────────┤
│                                                                             │
│  시간 ──────────────────────────────────────────────────────────────────►   │
│        0초        10초        20초        30초        40초        45초      │
│         │          │          │          │          │          │            │
│  서버A  │ 락 획득  │ TTL갱신  │ TTL갱신  │ TTL갱신  │ 작업완료 │ 락해제    │
│         │ TTL:30초 │ TTL:30초 │ TTL:30초 │ TTL:30초 │          │            │
│         │          │    ▲     │    ▲     │    ▲     │          │            │
│         │          │    │     │    │     │    │     │          │            │
│         │          │ Watchdog │ Watchdog │ Watchdog │          │            │
│         │          │ (10초마다 자동 갱신)             │          │            │
│                                                                             │
│  서버B  │──────────────────── 대기 중 ──────────────────────────│ 락 획득   │
│                                                                             │
│  ✓ 작업 완료 시까지 락 유지 → 데이터 일관성 보장                           │
│                                                                             │
└─────────────────────────────────────────────────────────────────────────────┘
```

#### Watchdog 활성화 방법

```java
// Watchdog 활성화 (leaseTime = -1 또는 생략)
// 기본 30초, 10초마다 자동 갱신
lock.tryLock(waitTime, -1, TimeUnit.SECONDS);  // ✓ Watchdog ON

// Watchdog 비활성화 (leaseTime 직접 지정)
// 지정 시간 후 자동 만료, 갱신 없음
lock.tryLock(waitTime, 30, TimeUnit.SECONDS);  // ✗ Watchdog OFF

// 언제 Watchdog을 사용할까?
// ┌─────────────────────────────────────────────────────────────────────┐
// │ Watchdog ON:  작업 시간을 예측할 수 없을 때                          │
// │              예) 외부 API 호출, 대용량 데이터 처리                   │
// │                                                                      │
// │ Watchdog OFF: 작업 시간이 명확하고, 서버 장애 시 빠른 복구 필요할 때│
// │              예) 단순 DB 업데이트 (확실히 5초 이내)                  │
// └─────────────────────────────────────────────────────────────────────┘
```

---

## 7. 메시지 큐 (Redis Stream)

### Q7-1. Redis Stream이 무엇이고, 언제 사용하나요?

**모범 답안:**

#### Redis Stream 아키텍처

```
┌─────────────────────────────────────────────────────────────────────────────┐
│                         Redis Stream 구조                                    │
├─────────────────────────────────────────────────────────────────────────────┤
│                                                                             │
│                           Redis Stream: "orders"                            │
│  ═════════════════════════════════════════════════════════════════════════ │
│                                                                             │
│     시간 ──────────────────────────────────────────────────────────────►    │
│                                                                             │
│     Entry 1              Entry 2              Entry 3              Entry 4  │
│  ┌──────────────┐    ┌──────────────┐    ┌──────────────┐    ┌──────────┐  │
│  │ ID: 1234-0   │    │ ID: 1234-1   │    │ ID: 1235-0   │    │ ID:1236-0│  │
│  │ orderId: 101 │    │ orderId: 102 │    │ orderId: 103 │    │orderId:104│ │
│  │ amount: 1000 │    │ amount: 2000 │    │ amount: 500  │    │amount:3000│ │
│  └──────────────┘    └──────────────┘    └──────────────┘    └──────────┘  │
│         │                   │                   │                  │        │
│         │                   │                   │                  │        │
│         ▼                   ▼                   ▼                  ▼        │
│  ┌─────────────────────────────────────────────────────────────────────┐   │
│  │                    Consumer Group: "order-processors"                │   │
│  │                                                                      │   │
│  │   Consumer 1        Consumer 2        Consumer 3                    │   │
│  │   (서버 A)          (서버 B)          (서버 C)                       │   │
│  │      │                 │                 │                          │   │
│  │      ▼                 ▼                 ▼                          │   │
│  │   Entry 1           Entry 2           Entry 3                       │   │
│  │   Entry 4           (처리 중)         (처리 완료, ACK)              │   │
│  │                                                                      │   │
│  │   → 메시지 자동 분배 (로드 밸런싱)                                  │   │
│  └─────────────────────────────────────────────────────────────────────┘   │
│                                                                             │
│  특징:                                                                      │
│  ┌─────────────────────────────────────────────────────────────────────┐   │
│  │ ✓ 영속성: 메시지가 Redis에 저장됨                                   │   │
│  │ ✓ Consumer Group: 여러 소비자가 메시지 분배                         │   │
│  │ ✓ ACK: 메시지 처리 확인                                             │   │
│  │ ✓ 재처리: 실패한 메시지 다시 처리 가능 (Pending List)               │   │
│  │ ✓ 메시지 ID: 타임스탬프 기반 자동 생성                              │   │
│  └─────────────────────────────────────────────────────────────────────┘   │
│                                                                             │
└─────────────────────────────────────────────────────────────────────────────┘
```

#### Kafka vs Redis Stream 비교

| 구분 | Kafka | Redis Stream |
|------|-------|--------------|
| 아키텍처 | 분산 로그 | 인메모리 + 영속화 |
| 설정 복잡도 | 높음 (ZooKeeper 필요) | **낮음** (Redis만 있으면 됨) |
| 처리량 | 매우 높음 (초당 백만) | 높음 (초당 십만) |
| 지연 시간 | 밀리초 | **마이크로초** |
| 메시지 보존 | 무제한 (설정) | 메모리 제한 |
| 학습 목적 | 복잡한 설정 필요 | **빠른 시작 가능** |

---

### Q7-2. Consumer Group과 Pending List는 무엇인가요?

**모범 답안:**

#### Consumer Group 동작 방식

```
┌─────────────────────────────────────────────────────────────────────────────┐
│                      Consumer Group 메시지 분배                              │
├─────────────────────────────────────────────────────────────────────────────┤
│                                                                             │
│                         Stream: "orders"                                    │
│                              │                                              │
│              ┌───────────────┼───────────────┐                              │
│              │               │               │                              │
│              ▼               ▼               ▼                              │
│         Message 1       Message 2       Message 3                           │
│              │               │               │                              │
│              │    Consumer Group 분배        │                              │
│              │               │               │                              │
│         ┌────┴────┐    ┌────┴────┐    ┌────┴────┐                          │
│         │Consumer1│    │Consumer2│    │Consumer3│                          │
│         │(서버 A) │    │(서버 B) │    │(서버 C) │                          │
│         └────┬────┘    └────┬────┘    └────┬────┘                          │
│              │               │               │                              │
│         처리 완료        처리 중         처리 완료                          │
│              │               │               │                              │
│           XACK          Pending           XACK                              │
│                                                                             │
│  핵심: 각 메시지는 그룹 내 하나의 Consumer에게만 전달됨                     │
│                                                                             │
└─────────────────────────────────────────────────────────────────────────────┘
```

#### Pending List와 메시지 복구

```
┌─────────────────────────────────────────────────────────────────────────────┐
│                         Pending List 동작                                    │
├─────────────────────────────────────────────────────────────────────────────┤
│                                                                             │
│  시나리오: Consumer 2가 Message 2 처리 중 장애 발생                        │
│                                                                             │
│  시간 ──────────────────────────────────────────────────────────────────►   │
│                                                                             │
│  Consumer 2:                                                                │
│  ┌──────────────────────────────────────────────────────────────────────┐  │
│  │ 1. XREADGROUP으로 Message 2 수신                                     │  │
│  │ 2. 처리 시작...                                                      │  │
│  │ 3. 💥 서버 다운! (ACK 전에 장애)                                     │  │
│  │                                                                       │  │
│  │ → Message 2는 Pending List에 남음                                    │  │
│  └──────────────────────────────────────────────────────────────────────┘  │
│                                                                             │
│  Pending List:                                                              │
│  ┌──────────────────────────────────────────────────────────────────────┐  │
│  │  Message ID    │  Consumer  │  Idle Time │  Delivery Count           │  │
│  │  1234-1        │  consumer2 │  60000ms   │  1                        │  │
│  │  (Message 2)   │  (다운됨)  │  (1분 경과)│  (1번 전달됨)             │  │
│  └──────────────────────────────────────────────────────────────────────┘  │
│                                                                             │
│  복구 프로세스 (Consumer 1이 인계):                                        │
│  ┌──────────────────────────────────────────────────────────────────────┐  │
│  │ 1. XPENDING orders group → Pending 메시지 조회                       │  │
│  │ 2. XCLAIM orders group consumer1 60000 1234-1 → 소유권 이전          │  │
│  │ 3. 메시지 재처리                                                     │  │
│  │ 4. XACK orders group 1234-1 → 처리 완료                              │  │
│  └──────────────────────────────────────────────────────────────────────┘  │
│                                                                             │
│  핵심 명령어:                                                               │
│  XPENDING stream group              # Pending 목록 조회                    │
│  XCLAIM stream group consumer ...   # 다른 Consumer에게 소유권 이전        │
│  XACK stream group message-id       # 처리 완료 확인                       │
│                                                                             │
└─────────────────────────────────────────────────────────────────────────────┘
```

---

### Q7-3. Outbox 패턴이 무엇인가요?

**모범 답안:**

#### 이중 쓰기 문제

```
┌─────────────────────────────────────────────────────────────────────────────┐
│                       이중 쓰기 (Dual Write) 문제                            │
├─────────────────────────────────────────────────────────────────────────────┤
│                                                                             │
│  Order Service                                                              │
│       │                                                                     │
│       │ 1. 주문 저장                                                        │
│       │                                                                     │
│       ├─────────────────────► [Order DB]                                    │
│       │                       INSERT INTO orders... ✓ 성공                  │
│       │                                                                     │
│       │ 2. 이벤트 발행                                                      │
│       │                                                                     │
│       └─────────────────────► [Message Queue]                               │
│                               PUBLISH order_created... ✗ 실패!              │
│                                                                             │
│  ─────────────────────────────────────────────────────────────────────────  │
│                                                                             │
│  결과:                                                                      │
│  ┌─────────────────────────────────────────────────────────────────────┐   │
│  │  Order DB: 주문 데이터 존재 ✓                                       │   │
│  │  Message Queue: 이벤트 없음 ✗                                       │   │
│  │                                                                      │   │
│  │  → 다른 서비스들이 주문 생성을 알지 못함                            │   │
│  │  → 재고 차감, 결제 처리 등이 누락됨                                 │   │
│  │  → 데이터 불일치!                                                   │   │
│  └─────────────────────────────────────────────────────────────────────┘   │
│                                                                             │
└─────────────────────────────────────────────────────────────────────────────┘
```

#### Outbox 패턴 해결

```
┌─────────────────────────────────────────────────────────────────────────────┐
│                         Outbox 패턴 구조                                     │
├─────────────────────────────────────────────────────────────────────────────┤
│                                                                             │
│  Order Service                                                              │
│       │                                                                     │
│       │ 1. 같은 트랜잭션에서 주문 + Outbox 저장                            │
│       │                                                                     │
│       │    BEGIN TRANSACTION                                                │
│       ├────────────────────────► [Order DB]                                │
│       │                          ├── orders 테이블: INSERT order           │
│       │                          └── outbox 테이블: INSERT event          │
│       │    COMMIT                                                          │
│       │                          ← 원자적 처리 (둘 다 성공 or 둘 다 실패)  │
│       │                                                                     │
│                                                                             │
│  Message Relay (별도 프로세스)                                              │
│       │                                                                     │
│       │ 2. Outbox 테이블 폴링                                              │
│       │                                                                     │
│       │    SELECT * FROM outbox WHERE published = false                    │
│       ├────────────────────────► [Order DB]                                │
│       │                                                                     │
│       │ 3. 메시지 발행                                                     │
│       │                                                                     │
│       ├────────────────────────► [Message Queue]                           │
│       │                          PUBLISH order_created ✓                   │
│       │                                                                     │
│       │ 4. 상태 업데이트                                                   │
│       │                                                                     │
│       │    UPDATE outbox SET published = true WHERE id = ?                 │
│       └────────────────────────► [Order DB]                                │
│                                                                             │
│  ─────────────────────────────────────────────────────────────────────────  │
│                                                                             │
│  Outbox 테이블 구조:                                                        │
│  ┌─────────────────────────────────────────────────────────────────────┐   │
│  │  id  │ event_type     │ payload                    │ published │   │   │
│  │  1   │ ORDER_CREATED  │ {"orderId":1, "amount":100}│ false     │   │   │
│  │  2   │ ORDER_CREATED  │ {"orderId":2, "amount":200}│ true      │   │   │
│  └─────────────────────────────────────────────────────────────────────┘   │
│                                                                             │
│  장점:                                                                      │
│  ✓ DB 트랜잭션으로 원자성 보장 (At-Least-Once)                             │
│  ✓ 메시지 발행 실패해도 재시도 가능                                        │
│  ✓ 이벤트 순서 보장                                                        │
│  ✓ 메시지 발행 이력 추적 가능                                              │
│                                                                             │
└─────────────────────────────────────────────────────────────────────────────┘
```

---

## 8. Temporal

### Q8-1. Temporal이 무엇이고, 어떤 문제를 해결하나요?

**모범 답안:**

#### 기존 Saga 구현의 어려움

```
┌─────────────────────────────────────────────────────────────────────────────┐
│                      기존 Saga 직접 구현 시 어려움                           │
├─────────────────────────────────────────────────────────────────────────────┤
│                                                                             │
│  1. 상태 관리 복잡                                                          │
│  ══════════════════                                                         │
│     "현재 Saga가 어디까지 진행됐지?"                                        │
│     "이 주문은 재고 차감까지 됐나, 결제까지 됐나?"                          │
│     → saga_state 테이블 직접 관리 필요                                      │
│                                                                             │
│  2. 보상 트랜잭션 복잡                                                      │
│  ══════════════════════                                                     │
│     결제 실패 시:                                                           │
│     - 재고 복구해야 하나? (이미 차감됐다면)                                │
│     - 주문 취소해야 하나? (이미 생성됐다면)                                │
│     → 수많은 if-else 분기                                                   │
│                                                                             │
│  3. 재시도 로직 산재                                                        │
│  ══════════════════                                                         │
│     모든 서비스 호출마다:                                                   │
│     while (retryCount < 3) {                                                │
│         try { ... } catch (Exception e) { retryCount++; wait(); }          │
│     }                                                                       │
│     → 코드 중복, 일관성 없음                                                │
│                                                                             │
│  4. 타임아웃 처리                                                           │
│  ═════════════════                                                          │
│     "결제 서비스가 30초 동안 응답 없으면 어떻게 하지?"                      │
│     "타임아웃 후 실제로는 성공했으면?"                                      │
│     → 복잡한 예외 처리                                                      │
│                                                                             │
│  5. 서버 다운 후 복구                                                       │
│  ══════════════════════                                                     │
│     서버 A 다운 → "진행 중이던 Saga들은 어떻게 되지?"                       │
│     서버 B가 인계? → "어디까지 진행됐는지 어떻게 알지?"                     │
│     → 별도의 복구 로직 필요                                                 │
│                                                                             │
└─────────────────────────────────────────────────────────────────────────────┘
```

#### Temporal이 해결하는 방법

```
┌─────────────────────────────────────────────────────────────────────────────┐
│                         Temporal의 해결책                                    │
├─────────────────────────────────────────────────────────────────────────────┤
│                                                                             │
│                     ┌─────────────────────────┐                             │
│                     │    Temporal Server      │                             │
│                     │                         │                             │
│                     │  ┌─────────────────┐   │                             │
│                     │  │  Event History  │   │  ← 모든 이벤트 자동 기록    │
│                     │  │  WorkflowStarted│   │                             │
│                     │  │  ActivityStarted│   │                             │
│                     │  │  ActivityCompleted│  │                             │
│                     │  │  ...            │   │                             │
│                     │  └─────────────────┘   │                             │
│                     │                         │                             │
│                     │  ┌─────────────────┐   │                             │
│                     │  │   Task Queue    │   │                             │
│                     │  │   "order-queue" │   │                             │
│                     │  └─────────────────┘   │                             │
│                     └────────────┬────────────┘                             │
│                                  │                                          │
│              ┌───────────────────┼───────────────────┐                      │
│              ▼                   ▼                   ▼                      │
│       ┌──────────┐        ┌──────────┐        ┌──────────┐                 │
│       │ Worker 1 │        │ Worker 2 │        │ Worker 3 │                 │
│       │ (서버 A) │        │ (서버 B) │        │ (서버 C) │                 │
│       └──────────┘        └──────────┘        └──────────┘                 │
│                                                                             │
│  ─────────────────────────────────────────────────────────────────────────  │
│                                                                             │
│  Temporal이 자동 처리하는 것:                                               │
│  ┌─────────────────────────────────────────────────────────────────────┐   │
│  │ ✓ 상태 관리: Event Sourcing으로 자동 기록/복원                      │   │
│  │ ✓ 보상 트랜잭션: Saga 패턴 내장 (실패 시 자동 보상 호출)            │   │
│  │ ✓ 재시도: Retry Policy 선언적 설정                                  │   │
│  │ ✓ 타임아웃: Activity Timeout 내장                                   │   │
│  │ ✓ 장애 복구: 서버 다운 후 자동 재개 (Durable Execution)             │   │
│  └─────────────────────────────────────────────────────────────────────┘   │
│                                                                             │
└─────────────────────────────────────────────────────────────────────────────┘
```

---

### Q8-2. Workflow와 Activity의 차이는 무엇인가요?

**모범 답안:**

#### Workflow vs Activity 역할 분리

```
┌─────────────────────────────────────────────────────────────────────────────┐
│                     Workflow vs Activity 역할                                │
├─────────────────────────────────────────────────────────────────────────────┤
│                                                                             │
│  Workflow (오케스트레이터)                Activity (실행자)                 │
│  ═══════════════════════════              ══════════════════                │
│                                                                             │
│  "무엇을 어떤 순서로 할지"               "실제 작업 수행"                   │
│                                                                             │
│  ┌─────────────────────────┐            ┌─────────────────────────┐        │
│  │ @WorkflowMethod         │            │ @ActivityMethod         │        │
│  │ public void execute() { │            │ public void reserveStock│        │
│  │                         │            │   (Long productId) {    │        │
│  │   // 흐름 정의          │  ───────►  │                         │        │
│  │   activities.createOrder();│         │   // 실제 DB 호출       │        │
│  │   activities.reserveStock();│        │   inventory.decrease(); │        │
│  │   activities.processPayment();│      │                         │        │
│  │                         │            │ }                       │        │
│  │ }                       │            └─────────────────────────┘        │
│  └─────────────────────────┘                                               │
│                                                                             │
│  ─────────────────────────────────────────────────────────────────────────  │
│                                                                             │
│  핵심 차이:                                                                 │
│                                                                             │
│  ┌─────────────────────────────────────────────────────────────────────┐   │
│  │  Workflow는 반드시 결정론적(Deterministic)이어야 함!                 │   │
│  │                                                                      │   │
│  │  ✗ 금지:                                                            │   │
│  │     Math.random()       // 매번 다른 값                              │   │
│  │     new Date()          // 매번 다른 시간                            │   │
│  │     UUID.randomUUID()   // 매번 다른 값                              │   │
│  │     Thread.sleep()      // 직접 대기                                 │   │
│  │     외부 API 직접 호출  // 결과 보장 없음                            │   │
│  │                                                                      │   │
│  │  ✓ 대신 사용:                                                       │   │
│  │     Workflow.newRandom()       // Temporal이 제공하는 랜덤          │   │
│  │     Workflow.currentTimeMillis() // 재생 가능한 시간                │   │
│  │     Workflow.sleep(Duration)    // 재생 가능한 대기                 │   │
│  │     Activity를 통해 호출        // 외부 호출은 Activity에서          │   │
│  │                                                                      │   │
│  │  이유: Replay(재생) 시 동일한 결과가 나와야 상태 복원 가능          │   │
│  └─────────────────────────────────────────────────────────────────────┘   │
│                                                                             │
└─────────────────────────────────────────────────────────────────────────────┘
```

#### 상세 비교표

| 구분 | Workflow | Activity |
|------|----------|----------|
| 역할 | 비즈니스 흐름 정의 | 실제 작업 수행 |
| 특징 | **결정론적** (Deterministic) | 비결정론적 가능 |
| 예시 | if/else, 상태 전이, 분기 | API 호출, DB 저장, 파일 I/O |
| 재시도 | 자동 재개 (Replay) | Retry Policy로 설정 |
| 실행 위치 | Temporal Worker | Temporal Worker |
| 타임아웃 | Workflow Execution Timeout | Activity Timeout (Start-to-Close) |

#### 코드 예시

```java
// Workflow Interface & Implementation
@WorkflowInterface
public interface OrderWorkflow {
    @WorkflowMethod
    OrderResult executeOrder(OrderRequest request);
}

public class OrderWorkflowImpl implements OrderWorkflow {

    private final OrderActivities activities = Workflow.newActivityStub(
        OrderActivities.class,
        ActivityOptions.newBuilder()
            .setStartToCloseTimeout(Duration.ofSeconds(30))  // 타임아웃
            .setRetryOptions(RetryOptions.newBuilder()       // 재시도
                .setMaximumAttempts(3)
                .build())
            .build());

    @Override
    public OrderResult executeOrder(OrderRequest request) {
        // Saga 패턴: 보상 트랜잭션 관리
        Saga saga = new Saga(new Saga.Options.Builder().build());

        try {
            // 결정론적 코드만!
            Long orderId = activities.createOrder(request);
            saga.addCompensation(() -> activities.cancelOrder(orderId));

            activities.reserveStock(orderId, request.getProductId());
            saga.addCompensation(() -> activities.restoreStock(orderId, request.getProductId()));

            activities.processPayment(orderId, request.getAmount());

            return new OrderResult(orderId, "COMPLETED");
        } catch (Exception e) {
            // 실패 시 등록된 보상 트랜잭션 역순 실행
            saga.compensate();
            throw e;
        }
    }
}

// Activity Interface & Implementation
@ActivityInterface
public interface OrderActivities {
    @ActivityMethod
    Long createOrder(OrderRequest request);

    @ActivityMethod
    void reserveStock(Long orderId, Long productId);

    @ActivityMethod
    void restoreStock(Long orderId, Long productId);  // 재고 복구 (보상)

    @ActivityMethod
    void processPayment(Long orderId, BigDecimal amount);

    @ActivityMethod
    void cancelOrder(Long orderId);  // 주문 취소 (보상)
}
```

---

### Q8-3. Temporal의 내구성 있는 실행(Durable Execution)이란?

**모범 답안:**

#### Durable Execution 동작 원리

```
┌─────────────────────────────────────────────────────────────────────────────┐
│                      Durable Execution (내구성 있는 실행)                    │
├─────────────────────────────────────────────────────────────────────────────┤
│                                                                             │
│  시나리오: 워크플로우 실행 중 Worker 서버 다운                              │
│                                                                             │
│  시간 ──────────────────────────────────────────────────────────────────►   │
│                                                                             │
│  Worker A:                                                                  │
│  ┌──────────────────────────────────────────────────────────────────────┐  │
│  │ 1. createOrder()  ✓ 완료                                             │  │
│  │ 2. reserveStock() ✓ 완료                                             │  │
│  │ 3. processPayment() 진행 중...                                       │  │
│  │                                                                       │  │
│  │    💥 서버 다운!                                                     │  │
│  └──────────────────────────────────────────────────────────────────────┘  │
│                                                                             │
│  Temporal Server (Event History):                                           │
│  ┌──────────────────────────────────────────────────────────────────────┐  │
│  │ Event 1: WorkflowExecutionStarted                                    │  │
│  │ Event 2: ActivityTaskScheduled (createOrder)                         │  │
│  │ Event 3: ActivityTaskCompleted (createOrder) → orderId: 123          │  │
│  │ Event 4: ActivityTaskScheduled (reserveStock)                        │  │
│  │ Event 5: ActivityTaskCompleted (reserveStock) → success              │  │
│  │ Event 6: ActivityTaskScheduled (processPayment)                      │  │
│  │ Event 7: ActivityTaskStarted (processPayment)                        │  │
│  │ ...  (서버 다운으로 미완료)                                          │  │
│  └──────────────────────────────────────────────────────────────────────┘  │
│                                                                             │
│  Worker B (서버 재시작 또는 다른 서버):                                    │
│  ┌──────────────────────────────────────────────────────────────────────┐  │
│  │ 1. Task Queue에서 미완료 워크플로우 인계                             │  │
│  │                                                                       │  │
│  │ 2. Event History Replay (재생)                                       │  │
│  │    ├── createOrder() 결과: orderId=123 (History에서 복원, 재실행 X)  │  │
│  │    ├── reserveStock() 결과: success (History에서 복원, 재실행 X)     │  │
│  │    └── processPayment() → 이 지점부터 재개!                          │  │
│  │                                                                       │  │
│  │ 3. processPayment() 실행 (실제 작업)                                 │  │
│  │ 4. 워크플로우 완료                                                   │  │
│  └──────────────────────────────────────────────────────────────────────┘  │
│                                                                             │
│  ─────────────────────────────────────────────────────────────────────────  │
│                                                                             │
│  핵심 원리:                                                                 │
│  ┌─────────────────────────────────────────────────────────────────────┐   │
│  │ 1. Event Sourcing: 모든 Activity 결과를 Temporal Server에 기록      │   │
│  │ 2. Replay: 서버 재시작 시 Event History 재생으로 상태 복원          │   │
│  │ 3. 이미 완료된 Activity는 재실행하지 않고 기록된 결과 사용          │   │
│  │                                                                      │   │
│  │ 결과: 서버가 몇 번 죽어도 워크플로우는 정확히 한 번 완료됨          │   │
│  │       (At-Most-Once가 아닌 Exactly-Once Semantics)                  │   │
│  └─────────────────────────────────────────────────────────────────────┘   │
│                                                                             │
└─────────────────────────────────────────────────────────────────────────────┘
```

---

### Q8-4. Temporal Worker는 무엇인가요?

**모범 답안:**

#### Worker 아키텍처

```
┌─────────────────────────────────────────────────────────────────────────────┐
│                         Temporal Worker 아키텍처                             │
├─────────────────────────────────────────────────────────────────────────────┤
│                                                                             │
│                      ┌─────────────────────────────────┐                    │
│                      │        Temporal Server          │                    │
│                      │                                 │                    │
│                      │   ┌─────────────────────────┐  │                    │
│                      │   │      Task Queue         │  │                    │
│                      │   │   "order-task-queue"    │  │                    │
│                      │   │                         │  │                    │
│                      │   │  ┌─────────────────┐   │  │                    │
│                      │   │  │ Workflow Task 1 │   │  │                    │
│                      │   │  │ Activity Task 2 │   │  │                    │
│                      │   │  │ Activity Task 3 │   │  │                    │
│                      │   │  │ ...             │   │  │                    │
│                      │   │  └─────────────────┘   │  │                    │
│                      │   └─────────────────────────┘  │                    │
│                      └──────────────┬─────────────────┘                    │
│                                     │                                       │
│              ┌──────────────────────┼──────────────────────┐                │
│              │                      │                      │                │
│              │ Long Polling         │ Long Polling         │ Long Polling   │
│              │ (작업 대기)          │ (작업 대기)          │ (작업 대기)    │
│              ▼                      ▼                      ▼                │
│       ┌──────────────┐       ┌──────────────┐       ┌──────────────┐       │
│       │   Worker 1   │       │   Worker 2   │       │   Worker 3   │       │
│       │   (서버 A)   │       │   (서버 B)   │       │   (서버 C)   │       │
│       │              │       │              │       │              │       │
│       │ Workflows:   │       │ Workflows:   │       │ Workflows:   │       │
│       │ - OrderFlow  │       │ - OrderFlow  │       │ - OrderFlow  │       │
│       │              │       │              │       │              │       │
│       │ Activities:  │       │ Activities:  │       │ Activities:  │       │
│       │ - createOrder│       │ - createOrder│       │ - createOrder│       │
│       │ - reserve... │       │ - reserve... │       │ - reserve... │       │
│       │ - process... │       │ - process... │       │ - process... │       │
│       └──────────────┘       └──────────────┘       └──────────────┘       │
│                                                                             │
│  ─────────────────────────────────────────────────────────────────────────  │
│                                                                             │
│  Worker 역할:                                                               │
│  ┌─────────────────────────────────────────────────────────────────────┐   │
│  │ 1. Task Queue에서 작업을 Long Polling으로 가져옴                    │   │
│  │ 2. Workflow Task: 워크플로우 코드 실행 (흐름 결정)                  │   │
│  │ 3. Activity Task: Activity 코드 실행 (실제 작업)                    │   │
│  │ 4. 결과를 Temporal Server에 보고                                    │   │
│  │                                                                      │   │
│  │ 특징:                                                                │   │
│  │ - 무상태(Stateless): 상태는 Temporal Server에 저장                  │   │
│  │ - 수평 확장: Worker 추가로 처리량 증가                              │   │
│  │ - 장애 허용: 한 Worker 다운 시 다른 Worker가 인계                   │   │
│  └─────────────────────────────────────────────────────────────────────┘   │
│                                                                             │
└─────────────────────────────────────────────────────────────────────────────┘
```

#### Worker 등록 코드

```java
// Worker 설정 및 실행
@Configuration
public class TemporalWorkerConfig {

    @Bean
    public Worker orderWorker(WorkerFactory factory, OrderActivities activities) {
        // Task Queue 이름으로 Worker 생성
        Worker worker = factory.newWorker("order-task-queue");

        // Workflow 구현체 등록
        worker.registerWorkflowImplementationTypes(OrderWorkflowImpl.class);

        // Activity 구현체 등록 (Spring Bean 주입 가능)
        worker.registerActivitiesImplementations(activities);

        return worker;
    }

    @Bean
    public WorkerFactory workerFactory(WorkflowClient client) {
        return WorkerFactory.newInstance(client);
    }

    // Worker 시작
    @PostConstruct
    public void startWorkers() {
        workerFactory.start();
    }
}
```

---

## 9. Spring 관련

### Q9-1. Spring Profiles를 어떻게 활용하나요?

**모범 답안:**

**파일 구조:**
```
application.yml          # 공통 설정
application-local.yml    # 로컬 개발
application-dev.yml      # 개발 서버
application-prod.yml     # 운영 서버
```

**로드 순서:**
```
1. application.yml 로드
2. application-{active}.yml 로드 (덮어씀)

예: SPRING_PROFILES_ACTIVE=prod
→ application.yml + application-prod.yml
```

**환경별 설정 예시:**
```yaml
# application-local.yml
spring:
  datasource:
    url: jdbc:mysql://localhost:3306/order_db
  redis:
    host: localhost

# application-prod.yml
spring:
  datasource:
    url: jdbc:mysql://prod-db.example.com:3306/order_db
  redis:
    host: prod-redis.example.com
```

---

### Q9-2. @Transactional vs TransactionTemplate의 차이는?

**모범 답안:**

| 구분 | @Transactional | TransactionTemplate |
|------|----------------|---------------------|
| 방식 | 선언적 | 프로그래밍 방식 |
| 경계 | 메서드 단위 | 코드 블록 단위 |
| 유연성 | 제한적 | 높음 |
| 가독성 | 좋음 | 복잡할 수 있음 |

**TransactionTemplate 사용 시기:**
```java
// 여러 트랜잭션을 세밀하게 제어
public void complexOperation() {
    // 트랜잭션 1
    transactionTemplate.executeWithoutResult(status -> {
        orderRepository.save(order);
    });

    // 외부 API 호출 (트랜잭션 밖)
    externalApiClient.notify();

    // 트랜잭션 2
    transactionTemplate.executeWithoutResult(status -> {
        inventoryRepository.update(stock);
    });
}
```

---

### Q9-3. Bean Validation의 주요 어노테이션을 설명해주세요.

**모범 답안:**

| 어노테이션 | 용도 | 예시 |
|-----------|------|------|
| @NotNull | null 불가 | 필수 필드 |
| @NotBlank | null, 공백 불가 | 문자열 필수 |
| @NotEmpty | null, 빈 컬렉션 불가 | 리스트 필수 |
| @Size | 길이/크기 제한 | @Size(min=2, max=10) |
| @Min, @Max | 숫자 범위 | @Min(1) @Max(100) |
| @Email | 이메일 형식 | user@example.com |
| @Pattern | 정규식 | @Pattern(regexp="^[A-Z]+$") |
| @Valid | 중첩 객체 검증 | @Valid AddressDto address |

```java
public record OrderRequest(
    @NotNull(message = "상품 ID는 필수입니다")
    Long productId,

    @Positive(message = "수량은 1 이상이어야 합니다")
    Integer quantity,

    @Valid
    PaymentInfo paymentInfo
) {}
```

---

## 10. 데이터베이스 & ORM

### Q10-1. Flyway의 역할과 주의사항은 무엇인가요?

**모범 답안:**

**역할:**
- DB 스키마 버전 관리
- 팀원 간 스키마 동기화
- 배포 시 자동 마이그레이션

**파일 네이밍:**
```
V1__create_orders_table.sql      # 버전 1
V2__add_customer_id.sql          # 버전 2
V3__create_payments_table.sql    # 버전 3
R__refresh_views.sql             # 반복 실행 (R prefix)
```

**주의사항:**
```
1. 이미 실행된 스크립트 수정 금지
   → checksum 불일치로 에러 발생
   → 새 버전 파일로 수정사항 적용

2. 롤백은 새 마이그레이션으로
   V4__undo_v3.sql  # V3 변경사항을 되돌리는 새 스크립트
```

---

### Q10-2. JPA와 MyBatis를 함께 사용하는 이유는?

**모범 답안:**

**JPA 장점:**
- 생산성 (자동 쿼리 생성)
- ORM 추상화
- 간단한 CRUD

**MyBatis 장점:**
- SQL 직접 제어
- 복잡한 쿼리 최적화
- 멱등성 구현 용이

```sql
-- MyBatis로 멱등성 구현
INSERT IGNORE INTO payments (idempotency_key, amount)
VALUES (#{key}, #{amount})

-- MyBatis로 낙관적 락
UPDATE orders
SET status = #{status}, version = version + 1
WHERE id = #{id} AND version = #{version}
```

**결론:** "JPA로 기본 CRUD, MyBatis로 특수 케이스 처리"

---

### Q10-3. N+1 문제가 무엇이고, 어떻게 해결하나요?

**모범 답안:**

**문제:**
```java
List<Order> orders = orderRepository.findAll();  // 1번 쿼리
for (Order order : orders) {
    order.getItems().size();  // N번 쿼리 (지연 로딩)
}
// 총 N+1번 쿼리 실행
```

**해결 방법:**

1. **Fetch Join (JPQL)**
   ```java
   @Query("SELECT o FROM Order o JOIN FETCH o.items")
   List<Order> findAllWithItems();
   ```

2. **EntityGraph**
   ```java
   @EntityGraph(attributePaths = {"items"})
   List<Order> findAll();
   ```

3. **Batch Size**
   ```yaml
   spring:
     jpa:
       properties:
         hibernate:
           default_batch_fetch_size: 100
   ```

---

## 11. 모니터링 & 로깅

### Q11-1. MDC(Mapped Diagnostic Context)는 무엇이고, 왜 사용하나요?

**모범 답안:**

**정의:** 스레드 로컬 컨텍스트에 진단 정보를 저장하여 로그에 자동 포함

**필요한 이유:**
```
분산 시스템에서 요청 추적:
Client → Order Service → Inventory Service → Payment Service

MDC 없이:
[Order] Processing order
[Inventory] Reserving stock
[Payment] Processing payment
→ 어떤 요청인지 알 수 없음

MDC 사용:
[traceId=abc123] [Order] Processing order
[traceId=abc123] [Inventory] Reserving stock
[traceId=abc123] [Payment] Processing payment
→ 같은 traceId로 요청 흐름 추적 가능
```

**사용 예시:**
```java
@Component
public class MdcFilter implements Filter {
    @Override
    public void doFilter(ServletRequest req, ServletResponse res, FilterChain chain) {
        try {
            MDC.put("traceId", UUID.randomUUID().toString());
            MDC.put("userId", getUserId(req));
            chain.doFilter(req, res);
        } finally {
            MDC.clear();
        }
    }
}
```

---

### Q11-2. Prometheus와 Grafana의 역할은 무엇인가요?

**모범 답안:**

| 도구 | 역할 | 데이터 |
|------|------|--------|
| **Prometheus** | 메트릭 수집 & 저장 | 시계열 데이터 |
| **Grafana** | 시각화 & 대시보드 | 그래프, 알림 |

```
Spring Boot App
    │
    │ /actuator/prometheus (메트릭 노출)
    ▼
Prometheus ─────────────────────────┐
    │ (15초마다 스크랩)             │
    │                              │
    ▼                              ▼
시계열 DB ────────────────────→ Grafana
                                   │
                               대시보드
                               알림 설정
```

**주요 메트릭:**
- `http_server_requests_seconds`: HTTP 요청 지연 시간
- `jvm_memory_used_bytes`: JVM 메모리 사용량
- `process_cpu_usage`: CPU 사용률

---

### Q11-3. 분산 추적(Distributed Tracing)이 무엇인가요?

**모범 답안:**

**정의:** 여러 서비스를 거치는 요청의 전체 흐름을 추적하는 기술

```
Client ──→ Gateway ──→ Order ──→ Inventory ──→ Payment

Trace ID: abc-123
├── Span 1: Gateway (10ms)
├── Span 2: Order Service (50ms)
│   └── Span 3: Inventory Call (20ms)
│   └── Span 4: Payment Call (30ms)
└── Total: 110ms
```

**도구:**
- **Zipkin**: 경량, 간단한 설정
- **Jaeger**: Uber 개발, Kubernetes 친화적
- **OpenTelemetry**: 표준화된 수집 라이브러리

**Spring Boot 설정:**
```yaml
management:
  tracing:
    sampling:
      probability: 1.0  # 100% 샘플링 (운영에서는 0.1 등)
  zipkin:
    tracing:
      endpoint: http://localhost:9411/api/v2/spans
```

---

## 12. 인프라 & DevOps

### Q12-1. Docker Compose의 주요 개념을 설명해주세요.

**모범 답안:**

| 개념 | 설명 | 예시 |
|------|------|------|
| **Service** | 컨테이너 정의 | mysql, redis, app |
| **Volume** | 데이터 영속화 | mysql-data:/var/lib/mysql |
| **Network** | 컨테이너 간 통신 | backend (브릿지 네트워크) |
| **depends_on** | 시작 순서 | app depends_on mysql |
| **healthcheck** | 헬스 체크 | mysqladmin ping |

```yaml
services:
  mysql:
    image: mysql:8.0
    volumes:
      - mysql-data:/var/lib/mysql
    healthcheck:
      test: ["CMD", "mysqladmin", "ping"]
      interval: 10s
      timeout: 5s
      retries: 3

  app:
    build: .
    depends_on:
      mysql:
        condition: service_healthy

volumes:
  mysql-data:

networks:
  default:
    name: backend
```

---

### Q12-2. 컨테이너 오케스트레이션이 필요한 이유는?

**모범 답안:**

**Docker Compose의 한계:**
- 단일 호스트에서만 동작
- 자동 확장 불가
- 장애 복구 수동

**Kubernetes가 해결하는 문제:**
```
1. 자동 확장 (HPA)
   - CPU 80% 이상 → Pod 자동 증가

2. 자가 치유 (Self-healing)
   - Pod 죽으면 자동 재시작

3. 롤링 업데이트
   - 무중단 배포

4. 서비스 디스커버리
   - DNS 기반 서비스 찾기

5. 시크릿 관리
   - ConfigMap, Secret
```

**우리 프로젝트가 K8s를 사용하지 않는 이유:**
> "학습 목표에 집중하기 위해 Docker Compose로 충분한 로컬 환경 구성"

---

### Q12-3. 환경 변수 관리 전략은 어떻게 되나요?

**모범 답안:**

| 환경 | 전략 | 도구 |
|------|------|------|
| **로컬** | .env 파일 | Docker Compose |
| **CI/CD** | 파이프라인 시크릿 | GitHub Secrets |
| **Kubernetes** | ConfigMap/Secret | kubectl |
| **클라우드** | 관리형 서비스 | AWS Secrets Manager |

**12 Factor App 원칙:**
> "설정은 코드에서 분리하고 환경 변수로 주입"

```yaml
# docker-compose.yml
services:
  app:
    environment:
      - SPRING_PROFILES_ACTIVE=${PROFILE:-local}
      - DB_HOST=${DB_HOST:-localhost}
      - DB_PASSWORD=${DB_PASSWORD}  # .env에서 로드
```

---

## 부록: 면접 답변 템플릿

### 기술 개념 설명 시

```
1. 정의: "~란 ~를 의미합니다"
2. 필요성: "이 문제를 해결하기 위해 사용합니다"
3. 구현: "구체적인 방법은 ~입니다"
4. 장단점: "장점은 ~이고, 단점은 ~입니다"
5. 실무: "실제로는 ~에서 사용됩니다"
```

### 프로젝트 설명 시

```
1. 배경: "왜 이 프로젝트를 했는지"
2. 목표: "무엇을 달성하려 했는지"
3. 기술 선택: "왜 이 기술을 선택했는지"
4. 어려움: "어떤 문제가 있었는지"
5. 해결: "어떻게 해결했는지"
6. 결과: "무엇을 배웠는지"
```

---

## 참고 자료

- [프로젝트 아키텍처 결정](./architecture/DECISIONS.md)
- [기술 스택 검증](./architecture/TECH-STACK.md)
- [Phase별 학습 문서](./study/)
- [Temporal 공식 문서](https://docs.temporal.io/)
- [Resilience4j 가이드](https://resilience4j.readme.io/)
- [Redisson Wiki](https://github.com/redisson/redisson/wiki)
